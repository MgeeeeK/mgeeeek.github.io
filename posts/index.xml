<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Mragank Shekhar</title>
        <link>https://mgeeeek.github.io/posts/</link>
        <description>Recent content in Posts on Mragank Shekhar</description>
        <generator>Hugo -- gohugo.io</generator>
        <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
        <lastBuildDate>Fri, 31 Jul 2020 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://mgeeeek.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Coding period: second phase part 2</title>
            <link>https://mgeeeek.github.io/posts/2020/07/coding-period-second-phase-part-2/</link>
            <pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/07/coding-period-second-phase-part-2/</guid>
            <description>Phase two of GSoC2020 is over, this blog is little late cos my laptop&amp;rsquo;s HDD died and I was unable to save my Hugo environment. Overall the summer has been really productive and the API design of the interface is finally reached beta period, let&amp;rsquo;s look at the progress.
Final API of the Interface After several weeks of coding, design discussions, and code review, phase 1 of my project which consisted of designing API and all the functionality for the base raster interface is completed.</description>
            <content type="html"><![CDATA[<p><em>Phase two of GSoC2020 is over, this blog is little late cos my laptop&rsquo;s HDD died and I was unable to save my Hugo environment. Overall the summer has been really productive and the API design of the interface is finally reached beta period, let&rsquo;s look at the progress.</em></p>
<h2 id="final-api-of-the-interface">Final API of the Interface</h2>
<p>After several weeks of coding, design discussions, and code review, phase 1 of my project which consisted of designing API and all the functionality for the base raster interface is completed. In the last couple of weeks, I had to work on refactoring the methods to align them with the future design of the weights object, along with this there were some new test cases that I had to deal with as my earlier approach was focused only on <code>GDAL raster formats</code> and <code>open_rasterio</code> method which restricted the interface from being used with other datasets like <code>NetCDF</code> and therefore I&rsquo;d to work on refactoring and thinking what will be the best way to introduce this functionality in the interface.</p>
<p>These new changes were finalized after project meeting with my mentors, they explained that it&rsquo;ll be ideal if the support for other datasets is extended and the methods could be made more generalized. For this, a parameter <code>dims</code> was added to the weight builders, this argument will accept a dictionary, if dimensions of the <code>DataArray</code> does not match default dimensions which are <code>['band', 'time', 'lat', 'y', 'lon', 'x']</code>.</p>
<p>e.g. <code>dims</code> dictionary:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># none of the dimension belong to the default dimension list</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> da<span style="color:#f92672">.</span>dims                  
(<span style="color:#e6db74">&#39;year&#39;</span>, <span style="color:#e6db74">&#39;height&#39;</span>, <span style="color:#e6db74">&#39;width&#39;</span>)
<span style="color:#75715e"># dimension values should be properly aligned with the following keys</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> dims <span style="color:#f92672">=</span> {
        <span style="color:#e6db74">&#34;layer&#34;</span>: <span style="color:#e6db74">&#34;year&#34;</span>,
        <span style="color:#e6db74">&#34;lat&#34;</span>: <span style="color:#e6db74">&#34;height&#34;</span>,
        <span style="color:#e6db74">&#34;lon&#34;</span>: <span style="color:#e6db74">&#34;width&#34;</span>
    }
</code></pre></div><p>After adding new fixes, I worked on adding documentation and tests which took me a while to get my head around. After a few iterations of code review by my mentors, they notified me that I need to follow the <code>NumPy</code> doc convention for adding docstring. And in the last week of phase 2, I was able to finalize most of the work, you can check this pr which itself documents my progress in the second phase.</p>
<ul>
<li><a href="https://github.com/pysal/libpysal/pull/318">[WIP] : Base Raster Interface</a></li>
</ul>
<p>I&rsquo;ve provided an example notebook, which will try to cover the functionality offered by the raster interface.</p>
<h2 id="example-notebook-for-raster-awareness-api">Example Notebook for Raster awareness API</h2>
<p>This notebook will give an overview of newly developed raster interface. We&rsquo;ll cover
basic usage of the functionality offered by the interface which mainly involves:</p>
<ol>
<li>converting <code>xarray.DataArray</code> object to the PySAL&rsquo;s weights object (<code>libpysal.weights.W</code>/<code>WSP</code>).</li>
<li>going back to the <code>xarray.DataArray</code> from weights object.</li>
</ol>
<p>using different datasets:</p>
<ul>
<li>with missing values.</li>
<li>with multiple layers.</li>
<li>with non conventional dimension names.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">%</span>matplotlib inline

<span style="color:#f92672">from</span> libpysal.weights <span style="color:#f92672">import</span> Rook, Queen, KNN
<span style="color:#f92672">from</span> libpysal.weights <span style="color:#f92672">import</span> raster
<span style="color:#f92672">import</span> libpysal <span style="color:#f92672">as</span> lp
<span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> xarray <span style="color:#f92672">as</span> xr
<span style="color:#f92672">import</span> pandas <span style="color:#f92672">as</span> pd
<span style="color:#f92672">from</span> esda <span style="color:#f92672">import</span> Moran_Local
</code></pre></div><h3 id="loading-data">Loading Data</h3>
<p><em>The interface only accepts <code>xarray.DataArray</code></em>, this can be easily obtained from raster data
format using <code>xarray</code>'s I/O functionality which can read from a variety of data formats some of them are listed below:</p>
<ul>
<li><a href="https://svn.osgeo.org/gdal/tags/gdal_1_2_5/frmts/formats_list.html">GDAL Raster Formats</a> via <code>open_rasterio</code> method.</li>
<li><a href="https://www.unidata.ucar.edu/software/netcdf/">NetCDF</a> via <code>open_dataset</code> method.</li>
</ul>
<p>In this notebook we&rsquo;ll work with <code>NetCDF</code> and <code>GeoTIFF</code> data.</p>
<h4 id="using-local-netcdf-dataset">Using local <code>NetCDF</code> dataset</h4>
<p>In this small example we&rsquo;ll build <code>KNN</code> distance weight object using a local <code>NetCDF</code> dataset with different dimensions names which doesn&rsquo;t belong to the default list of dimensions.</p>
<p>We&rsquo;ll also see how to speed up the reverse journey (from weights object to <code>DataArray</code>) by passing prebuilt <code>coords</code> and <code>attrs</code> to <code>w2da</code> method.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># After loading netCDF dataset we obtained a xarray.Dataset object</span>
ds <span style="color:#f92672">=</span> xr<span style="color:#f92672">.</span>open_dataset(<span style="color:#e6db74">&#39;ECMWF_ERA-40_subset.nc&#39;</span>)
<span style="color:#75715e"># This Dataset object containes several data variables    </span>
<span style="color:#66d9ef">print</span>(ds)                                         
</code></pre></div><pre><code>&lt;xarray.Dataset&gt;
Dimensions:    (latitude: 73, longitude: 144, time: 62)
Coordinates:
  * longitude  (longitude) float32 0.0 2.5 5.0 7.5 ... 350.0 352.5 355.0 357.5
  * latitude   (latitude) float32 90.0 87.5 85.0 82.5 ... -85.0 -87.5 -90.0
  * time       (time) datetime64[ns] 2002-07-01T12:00:00 ... 2002-07-31T18:00:00
Data variables:
    tcw        (time, latitude, longitude) float32 ...
    tcwv       (time, latitude, longitude) float32 ...
    lsp        (time, latitude, longitude) float32 ...
    cp         (time, latitude, longitude) float32 ...
    msl        (time, latitude, longitude) float32 ...
    blh        (time, latitude, longitude) float32 ...
    tcc        (time, latitude, longitude) float32 ...
    p10u       (time, latitude, longitude) float32 ...
    p10v       (time, latitude, longitude) float32 ...
    p2t        (time, latitude, longitude) float32 ...
    p2d        (time, latitude, longitude) float32 ...
    e          (time, latitude, longitude) float32 ...
    lcc        (time, latitude, longitude) float32 ...
    mcc        (time, latitude, longitude) float32 ...
    hcc        (time, latitude, longitude) float32 ...
    tco3       (time, latitude, longitude) float32 ...
    tp         (time, latitude, longitude) float32 ...
Attributes:
    Conventions:  CF-1.0
    history:      2004-09-15 17:04:29 GMT by mars2netcdf-0.92
</code></pre>
<p>Out of 17 data variables we&rsquo;ll use <code>p2t</code> for our analysis. This will give us our desired <code>DataArray</code> object <code>da</code>, we will further group <code>da</code> by day, taking average over the <code>time</code> dimension.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># this will give us the required DataArray with p2t (2 metre temperature) data variable</span>
da <span style="color:#f92672">=</span> ds[<span style="color:#e6db74">&#34;p2t&#34;</span>]  
da <span style="color:#f92672">=</span> da<span style="color:#f92672">.</span>groupby(<span style="color:#e6db74">&#39;time.day&#39;</span>)<span style="color:#f92672">.</span>mean()
<span style="color:#66d9ef">print</span>(da<span style="color:#f92672">.</span>dims)
</code></pre></div><pre><code>('day', 'latitude', 'longitude')
</code></pre>
<p><strong>Weight builders (<code>from_xarray</code>, <code>da2W</code>, <code>da2WSP</code>) can recognise dimensions belonging to this list <code>[band, time, lat, y, lon, x]</code>, if any of the dimension in the <code>DataArray</code> does not belong to the mentioned list then we need to pass a dictionary (specifying that dimension’s name) to the weight builder. We can see that the none of dimensions of <code>da</code> matches with the default dimensions (<code>[band, time, lat, y, lon, x]</code>)</strong></p>
<p>This means we have to create a dictionary mentioning the dimensions and ship it to weight builder, similar to our last example.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">dims <span style="color:#f92672">=</span> {}
dims[<span style="color:#e6db74">&#34;lat&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;latitude&#34;</span>
dims[<span style="color:#e6db74">&#34;lon&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;longitude&#34;</span>
dims[<span style="color:#e6db74">&#34;layer&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;day&#34;</span>
w_knn <span style="color:#f92672">=</span> KNN<span style="color:#f92672">.</span>from_xarray(da, layer<span style="color:#f92672">=</span><span style="color:#ae81ff">13</span>, dims<span style="color:#f92672">=</span>dims, k<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># we can derive the data from DataArray using index attribute</span>
data <span style="color:#f92672">=</span> da<span style="color:#f92672">.</span>to_series()[w_knn<span style="color:#f92672">.</span>index]  
</code></pre></div><p>We can now speed up <code>w2da</code> by passing <code>coords</code> from the existing <code>DataArray</code> <code>da</code> which we used earlier.</p>
<p>Along with <code>coords</code> we can also pass <code>attrs</code> of the same <code>DataArray</code> this will help <code>w2da</code> to retain all the properties of original <code>DataArray</code>.</p>
<p>Let&rsquo;s compare the <code>DataArray</code> returned by <code>w2da</code> and original <code>DataArray</code>. For this we&rsquo;ll ship the derived data straight to <code>w2da</code> without any statistical analysis.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">da1 <span style="color:#f92672">=</span> raster<span style="color:#f92672">.</span>w2da(data, w_knn, attrs<span style="color:#f92672">=</span>da<span style="color:#f92672">.</span>attrs, coords<span style="color:#f92672">=</span>da[<span style="color:#ae81ff">12</span>:<span style="color:#ae81ff">13</span>]<span style="color:#f92672">.</span>coords)
<span style="color:#75715e"># method to compare 2 DataArray, if true then w2da was successfull</span>
xr<span style="color:#f92672">.</span>DataArray<span style="color:#f92672">.</span>equals(da[<span style="color:#ae81ff">12</span>:<span style="color:#ae81ff">13</span>], da1)  
</code></pre></div><pre><code>True
</code></pre>
<h4 id="using-local-geotiff-dataset">Using local <code>GeoTIFF</code> dataset</h4>
<p>Up until now we&rsquo;ve only played with <code>netCDF</code> datasets but in this example we&rsquo;ll use a <code>raster.tif</code> file to see how interface interacts with it. We&rsquo;ll also see how these methods handle missing data.</p>
<p>Unlike earlier we&rsquo;ll use weight builder methods from <code>raster.py</code>, which we can call directly. Just a reminder that <code>from_xarray</code> uses methods from <code>raster.py</code> and therefore only difference exists in the API.</p>
<p>To access GDAL Raster Formats xarray offers <code>open_rasterio</code> method which uses <code>rasterio</code> as backend. It loads metadata, coordinate values from the raster file and assign them to the <code>DataArray</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Loading raster data with missing values</span>
da <span style="color:#f92672">=</span> xr<span style="color:#f92672">.</span>open_rasterio(<span style="color:#e6db74">&#39;lux_ppp_2019.tif&#39;</span>)
<span style="color:#66d9ef">print</span>(da)
</code></pre></div><pre><code>&lt;xarray.DataArray (band: 1, y: 880, x: 940)&gt;
[827200 values with dtype=float32]
Coordinates:
  * band     (band) int64 1
  * y        (y) float64 50.18 50.18 50.18 50.18 ... 49.45 49.45 49.45 49.45
  * x        (x) float64 5.745 5.746 5.747 5.747 ... 6.525 6.526 6.527 6.527
Attributes:
    transform:      (0.0008333333297872345, 0.0, 5.744583325, 0.0, -0.0008333...
    crs:            +init=epsg:4326
    res:            (0.0008333333297872345, 0.0008333333295454553)
    is_tiled:       0
    nodatavals:     (-99999.0,)
    scales:         (1.0,)
    offsets:        (0.0,)
    AREA_OR_POINT:  Area
</code></pre>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># we can see that the DataArray contains missing values.</span>
da<span style="color:#f92672">.</span>where(da<span style="color:#f92672">.</span>values<span style="color:#f92672">&gt;</span>da<span style="color:#f92672">.</span>attrs[<span style="color:#e6db74">&#34;nodatavals&#34;</span>][<span style="color:#ae81ff">0</span>])<span style="color:#f92672">.</span>plot() 
</code></pre></div><pre><code>&lt;matplotlib.collections.QuadMesh at 0x7f27287a3550&gt;
</code></pre>

    <img src="/images/Raster_awareness_API_29_1.png"  alt="png"  class="center"  />


<p>We&rsquo;ll look at how weight builders handle missing values. Firstly we&rsquo;ll slice the <code>DataArray</code> to reduce overall size for easier visualization.</p>
<p>This time we&rsquo;ll create <code>WSP</code> object using <code>da2WSP</code> method inside <code>raster.py</code>. Since our DataArray is single banded and all of its dimensions belong to the default list, we&rsquo;ve to only ship the DataArray to the <code>da2WSP</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Slicing the dataarray</span>
da_s <span style="color:#f92672">=</span> da[:, <span style="color:#ae81ff">330</span>:<span style="color:#ae81ff">340</span>, <span style="color:#ae81ff">129</span>:<span style="color:#ae81ff">139</span>]
w_queen <span style="color:#f92672">=</span> raster<span style="color:#f92672">.</span>da2WSP(da_s)  <span style="color:#75715e"># default contiguity is queen</span>
w_rook <span style="color:#f92672">=</span> raster<span style="color:#f92672">.</span>da2WSP(da_s, <span style="color:#e6db74">&#34;rook&#34;</span>)
</code></pre></div><p>After plotting both contiguities and sliced <code>DataArray</code>, we can see that the missing values are ignored by the <code>da2WSP</code> method and only indices of non missing values are stored in <code>index</code> attribute of <code>WSP</code> object.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">f,ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>,figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">4</span><span style="color:#f92672">*</span><span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">4</span>), subplot_kw<span style="color:#f92672">=</span>dict(aspect<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;equal&#39;</span>))
da_s<span style="color:#f92672">.</span>where(da_s<span style="color:#f92672">.</span>values<span style="color:#f92672">&gt;</span>da_s<span style="color:#f92672">.</span>attrs[<span style="color:#e6db74">&#34;nodatavals&#34;</span>][<span style="color:#ae81ff">0</span>])<span style="color:#f92672">.</span>plot(ax<span style="color:#f92672">=</span>ax[<span style="color:#ae81ff">0</span>])
ax[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;Sliced raster&#34;</span>)
plot_spatial_weights(w_rook, da_s, ax<span style="color:#f92672">=</span>ax[<span style="color:#ae81ff">1</span>])
ax[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;Rook contiguity&#34;</span>)
plot_spatial_weights(w_queen, da_s, ax<span style="color:#f92672">=</span>ax[<span style="color:#ae81ff">2</span>])
ax[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;Queen contiguity&#34;</span>)
plt<span style="color:#f92672">.</span>show()
</code></pre></div>
    <img src="/images/Raster_awareness_API_33_0.png"  alt="png"  class="center"  />


<h3 id="additional-resources">Additional resources</h3>
<ol>
<li><a href="http://xarray.pydata.org/en/stable/io.html">Reading and writing files using Xarray</a></li>
<li><a href="http://xarray.pydata.org/en/stable/data-structures.html">Xarray Data Structures</a></li>
</ol>
<h2 id="whats-next">What&rsquo;s next?</h2>
<p>My first deliverable is almost complete (few bugs here and there stills exists and beta testing is still going on). This coding phase is dedicated towards optimizing and integration of raster interface. Regarding optimization, I&rsquo;ve succesfully built a faster raster weight builder using <code>numba</code> and <code>COO_matrix</code>, I&rsquo;m working on the multicore implementation for the same. After finishing high performant weight builder, I&rsquo;ll look into efficiently increasing the neighbors in the weights object.</p>
<p>Find out what happens next in the episode of GSoC2020&hellip; until then bye-bye 👋.</p>
]]></content>
        </item>
        
        <item>
            <title>Coding period: second phase part 1</title>
            <link>https://mgeeeek.github.io/posts/2020/07/coding-period-second-phase-part-1/</link>
            <pubDate>Fri, 17 Jul 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/07/coding-period-second-phase-part-1/</guid>
            <description>Phase 1 of the coding period has already completed and we&amp;rsquo;ve had almost reached the midpoint of the coding period. This blog will provide a short update of the work done in the last couple of weeks.
API Status At the end of Phase 1, there were some bug fixes and API changes that my mentors suggested, these were minor changes that were quickly included in the project in the following week.</description>
            <content type="html"><![CDATA[<p><em>Phase 1 of the coding period has already completed and we&rsquo;ve had almost reached the midpoint of the coding period. This blog will provide a short update of the work done in the last couple of weeks.</em></p>
<h2 id="api-status">API Status</h2>
<p>At the end of Phase 1, there were some bug fixes and API changes that my mentors suggested, these were minor changes that were quickly included in the project in the following week. After adding these changes the base raster interface was ready to get reviewed by the PySAL community and one of the main discussion topic was related to the attribute situation that the raster project was facing. After a detailed meeting with community members regarding the <code>W</code> object&hellip; which was really interesting as the conversation deep dived into the history and the API decisions went behind the creation of <code>W</code> object which is very core to the PySAL library as most methods are built around it, you can checkout these <a href="https://hackmd.io/Fozkz1IRQlK6GYVKI8mF9Q?both">meeting notes</a> anyway&hellip; one of the major change that was proposed is to shift towards <code>WSP</code> object (go through my last blogs to learn more about these 2 objects) additionally <code>id_order</code> attribute will be replaced by <code>index</code> which will contain instance of <code>pandas.Index</code> aligned with the ids of the weight object.
This required some changes in my existing implementation, since the API was finalized I created a pull request which can be accessed here -</p>
<ul>
<li><a href="https://github.com/pysal/libpysal/pull/318">[WIP] : Base Raster Interface</a></li>
</ul>
<p>I also started working on unit tests and documentation to go along with the interface. When I look back at my proposal I feel like I underestimated the first phase, this which was a mistake from my side as I never thought how much time it goes behind the designing the API.</p>
<h2 id="optimization-phase">Optimization Phase</h2>
<p>In the proposed timeline, after successfully delivering the base raster interface with complete and finalized API I planned to work on the optimization phase. Since the API was almost finished I started to think about possible solutions to improve the <em>performance</em> and <em>scalability</em> of the current methods. After my project related meeting with my mentors, we finalized several optimization related ideas that can be incorporated in the project. You can look into this issue which contains discussion related to the optimization phase -</p>
<ul>
<li><a href="https://github.com/pysal/libpysal/issues/293">Idea collection/discussion for Raster awareness project</a></li>
</ul>
<p>One of the more ambitious ideas was to create a <em>lazy graph mixin</em>, since a raster can be expressed as a regular lattice, we can build the weight object <em>on-the-fly</em> with only some information about raster in the memory. I explored this idea and pushed a <em>prototype</em> object which calculates neighbors of a given id lazily, it is still far from the real solution but it will help me to think more about this concept as it will significantly help the interface to work even on low memory.</p>
<ul>
<li><a href="https://github.com/MgeeeeK/libpysal/pull/7">[WIP] : Lazy weights object for raster interface</a></li>
</ul>
<p>Right now the top priority is to build the weights object with only <em>non-missing values</em> as the current approach builds a regular lattice and then removes the missing values using boolean masking which is computationally quite expensive. Along with this, I&rsquo;ve to think about how I can utilize almighty <code>numba</code> to further improve the performance of the builders, I&rsquo;ve experimented with this to improve the existing solution you can check the implementation here -</p>
<ul>
<li><a href="https://github.com/MgeeeeK/libpysal/pull/6">[WIP]: Raster optimization phase</a></li>
</ul>
<p>Once the base interface is merged I&rsquo;ll work on these solutions and explore more ways to optimize the interface.</p>
<h2 id="whats-next">What&rsquo;s next?</h2>
<p>Currently, my main focus is to complete the base raster interface by adding tests and documentation. After that, I&rsquo;ll look into ongoing optimization of the current methods and later explore ideas related to integrating the interface with other library components.</p>
<p>Goodbye 👋 fellow human, will meet you in the next blog.</p>
]]></content>
        </item>
        
        <item>
            <title>Coding period: first phase part 2</title>
            <link>https://mgeeeek.github.io/posts/2020/06/coding-period-first-phase-part-2/</link>
            <pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/06/coding-period-first-phase-part-2/</guid>
            <description>Phase 1 of the coding period is about to get over and 2 weeks have already passed since I gave an update on my GSoC project. As per my last blog, I successfully implemented the prototype transformation methods of the base interface, let’s look at the developments happened after the first 2 weeks.
Progress on the Project The main goal of the first phase was to implement and finalize the base raster interface, in other words, I had to incorporate all methods which can be utilized to make the transformations from xarray.</description>
            <content type="html"><![CDATA[<p><em>Phase 1 of the coding period is about to get over and 2 weeks have already passed since I gave an update on my GSoC project. As per my last <a href="https://mgeeeek.github.io/posts/2020/06/coding-period-first-phase-part-1/">blog</a>, I successfully implemented the prototype transformation methods of the base interface, let’s look at the developments happened after the first 2 weeks.</em></p>
<h2 id="progress-on-the-project">Progress on the Project</h2>
<p>The main goal of the first phase was to implement and finalize the base raster interface, in other words, I had to incorporate all methods which can be utilized to make the transformations from <code>xarray.DataArray</code> to both weight objects of PySAL (explained in my previous blog) and convert data back to <code>xarray.DataArray</code>. In the first 2 weeks of the coding period, we discussed the potential API of these methods and I worked on the prototype functions (this pr shows the initial prototype).</p>
<p>The proposed timeline in the project proposal for last 2 weeks is listed below:</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> Design the Uniform API which will aid in building the interface and in integrating well across PySAL library.</li>
<li><input checked="" disabled="" type="checkbox"> Finalize the logic of the transformational methods based on eager evaluation.</li>
<li><input disabled="" type="checkbox"> Add additional functionality to convert raster data straight to <code>Geo/Pandas Dataframe</code></li>
<li><input checked="" disabled="" type="checkbox"> Implement other required raster utility methods.</li>
<li><input checked="" disabled="" type="checkbox"> Create utility functions that will be required for reshaping and aligning the raster data with spatial weights matrix.</li>
<li><input checked="" disabled="" type="checkbox"> Create a functionality for processing the outputs from PySAL to write them out to <code>rasterio</code> object. (<em><code>rasterio</code> was replaced by <code>xarray</code>, read last blog for the reason</em>)</li>
</ul>
<p>Most of the tasks were achieved during this period except 3rd one which is not in our plan currently but I will look into it in the later stage.</p>
<h2 id="new-api-designenhancements">New API Design/Enhancements</h2>
<p>After several discussions with my mentors it was decided that the better way to present the transformational methods to the user is by using class methods through the contiguity classes (<code>Rook</code> and <code>Queen</code> for now). This required some modification in the existing weights object, current approach adds one additional attribute to store the coordinates of non-missing values (this will be further discussed with the rest of the community during this weeks group call). After finalizing the base interface by adding necessary changes targeting the community feedback I&rsquo;ll add the tests.</p>
<h2 id="example-notebook-for-raster-interface">Example Notebook for Raster Interface</h2>
<p>This notebook will provide an overview of ways we can use newly added raster interface to operate on raster data.</p>
<p><a href="https://mybinder.org/v2/gh/MgeeeeK/GSoC2020/master?filepath=gsoc_phase_1_raster_interface.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt="Binder"></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">%</span>matplotlib inline

<span style="color:#f92672">from</span> libpysal.weights <span style="color:#f92672">import</span> Rook, Queen
<span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> xarray <span style="color:#f92672">as</span> xr
<span style="color:#f92672">from</span> esda <span style="color:#f92672">import</span> Moran_Local
</code></pre></div><pre><code>/data/GSoC/libpysal/libpysal/weights/util.py:20: UserWarning: geopandas not available. Some functionality will be disabled.
  warn('geopandas not available. Some functionality will be disabled.')
</code></pre>
<p>Currently each method inside this interface only accepts <code>xarray.DataArray</code> as input, let&rsquo;s read in some data using <code>open_rasterio()</code> method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Multiband band raster data with no missing values</span>
da1 <span style="color:#f92672">=</span> xr<span style="color:#f92672">.</span>open_rasterio(<span style="color:#e6db74">&#39;HARV_RGB_Ortho.tif&#39;</span>)
<span style="color:#75715e"># Slicing the dataarray</span>
da1 <span style="color:#f92672">=</span> da1[:, <span style="color:#ae81ff">600</span>:<span style="color:#ae81ff">700</span>, <span style="color:#ae81ff">700</span>:<span style="color:#ae81ff">800</span>] 
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Ploting only first band of the da</span>
da1[:<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>plot()
</code></pre></div>
    <img src="/images/Untitled_4_1.png"  alt="png"  class="center"  />


<p>After accessing the raster data we will create weights object using a method called <code>from_xarray</code> from Rook class</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Let&#39;s check the method first</span>
help(Rook<span style="color:#f92672">.</span>from_xarray)
</code></pre></div><pre><code>Help on method from_xarray in module libpysal.weights.contiguity:

from_xarray(da, band=None, sparse=False, **kwargs) method of builtins.type instance
    Construct a weights object from a xarray.DataArray object 
    
    Parameters
    ----------
    da         : xarray.DataArray
                raster file accessed using xarray.open_rasterio method
    band       : int
                select band for raster with multiple bands
    sparse     : boolean
                type of weight object. Default is dense. For sparse, sparse = True
    **kwargs   : keyword arguments
                optional arguments for :class:`pysal.weights.W`
    See Also
    --------
    :class:`libpysal.weights.weights.W`
</code></pre>
<p><code>from_xarray</code> method will first check if data can be converted and if the bands is passed or not, if not passed then it&rsquo;ll select first band as default</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Creating weight of object from raster</span>
w_rook <span style="color:#f92672">=</span> Rook<span style="color:#f92672">.</span>from_xarray(da1)
</code></pre></div><pre><code>/data/GSoC/libpysal/libpysal/weights/raster.py:37: UserWarning: Multiple bands detected in the DataArray. Using default band 1 for further computation
  warn('Multiple bands detected in the DataArray. Using default band 1 for further computation')
</code></pre>
<p>This created weight object contains one additional attribute <code>coords</code> which stores the coordinates of non missing values in the form of <code>MultiIndex</code> of <code>pandas.Series</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Quick view at the data stored in coords</span>
w_rook<span style="color:#f92672">.</span>coords[:<span style="color:#ae81ff">5</span>]
</code></pre></div><pre><code>MultiIndex([(1, 4713385.375, 732173.625),
            (1, 4713385.375, 732173.875),
            (1, 4713385.375, 732174.125),
            (1, 4713385.375, 732174.375),
            (1, 4713385.375, 732174.625)],
           names=['band', 'y', 'x'])
</code></pre>
<p>After converting <code>DataArray</code> to <code>pandas,Series</code>, we can access non missing values of raster data (<em>this is still under process of review</em>)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Loading the raster data for further calculation</span>
data1 <span style="color:#f92672">=</span> da1<span style="color:#f92672">.</span>to_series()[w_rook<span style="color:#f92672">.</span>coords]
data1[:<span style="color:#ae81ff">5</span>]
</code></pre></div><pre><code>band  y            x         
1     4713385.375  732173.625    132.0
                   732173.875     94.0
                   732174.125     91.0
                   732174.375    110.0
                   732174.625    106.0
dtype: float64
</code></pre>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Quickly computing and loading a LISA</span>
np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">12345</span>)
lisa <span style="color:#f92672">=</span> Moran_Local(data1,w_rook)
</code></pre></div><p>We&rsquo;ll now try to convert computed data back to <code>xarray.DataArray</code>, we can use <code>to_xarray</code> method belonging to weight method for the transformation.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Let&#39;s check the method first</span>
help(w_rook<span style="color:#f92672">.</span>to_xarray)
</code></pre></div><pre><code>Help on method to_xarray in module libpysal.weights.weights:

to_xarray(data, indices=None, attrs=None) method of libpysal.weights.weights.W instance
    converts the aligned data to a `xarray.DataArray` object
    
    Arguments
    ---------
    data    :   array
                data values stored in 1d array
    indices :   Dictionary/xarray.core.coordinates.DataArrayCoordinates
                coordinates from original DataArray
    attrs   :   Dictionary
                attributes from original DataArray 
    Returns
    -------
    
    da : xarray.DataArray
        instance of xarray.DataArray
</code></pre>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Converting obtained data back to DataArray</span>
moran_da1 <span style="color:#f92672">=</span> w_rook<span style="color:#f92672">.</span>to_xarray(lisa<span style="color:#f92672">.</span>p_sim, da1<span style="color:#f92672">.</span>coords, da1<span style="color:#f92672">.</span>attrs)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Plotting the converted DataArray</span>
moran_da1<span style="color:#f92672">.</span>plot()
</code></pre></div>
    <img src="/images/Untitled_17_1.png"  alt="png"  class="center"  />


<p>We&rsquo;ll now perform same operations on different raster data</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># single band raster data with missing values</span>
da2 <span style="color:#f92672">=</span> xr<span style="color:#f92672">.</span>open_rasterio(<span style="color:#e6db74">&#39;nasadem_sd.tif&#39;</span>)
<span style="color:#75715e"># slicing the dataarray</span>
da2 <span style="color:#f92672">=</span> da2[:, :<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">300</span>:<span style="color:#ae81ff">400</span>]
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># ploting dataarray after removing missing values</span>
da2<span style="color:#f92672">.</span>where(da2<span style="color:#f92672">.</span>data<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>)<span style="color:#f92672">.</span>plot()
</code></pre></div>
    <img src="/images/Untitled_20_1.png"  alt="png"  class="center"  />


<p>This time we will create weights object using <code>Queen</code> class</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Creating weight of object from raster</span>
w_queen <span style="color:#f92672">=</span> Queen<span style="color:#f92672">.</span>from_xarray(da2)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Loading the raster data for further calculation</span>
data2 <span style="color:#f92672">=</span> da2<span style="color:#f92672">.</span>to_series()[w_queen<span style="color:#f92672">.</span>coords]
data2[:<span style="color:#ae81ff">5</span>]
</code></pre></div><pre><code>band  y       x          
1     33.505  -117.509444    256
              -117.509167    261
              -117.508889    263
              -117.508611    263
              -117.508333    264
dtype: int16
</code></pre>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Quickly computing and loading a LISA</span>
np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">12345</span>)
lisa <span style="color:#f92672">=</span> Moran_Local(data2,w_queen)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Let&#39;s check the method first</span>
moran_da2 <span style="color:#f92672">=</span> w_queen<span style="color:#f92672">.</span>to_xarray(lisa<span style="color:#f92672">.</span>p_sim, da2<span style="color:#f92672">.</span>coords, da2<span style="color:#f92672">.</span>attrs)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Plotting the converted DataArray</span>
moran_da2<span style="color:#f92672">.</span>where(moran_da2<span style="color:#f92672">.</span>data<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>)<span style="color:#f92672">.</span>plot()
</code></pre></div>
    <img src="/images/Untitled_26_1.png"  alt="png"  class="center"  />


<h2 id="experience">Experience</h2>
<p>Without a doubt, this summer has been very interesting and worthwhile with tons of knowledge gained and new things explored related to the project. After every interaction with my mentors, my appreciation for PySAL grow even more, I&rsquo;m able to understand the design decisions went behind the creation of APIs, different methods and overall structure of each module in PySAL library.</p>
<h2 id="whats-next">What’s next?</h2>
<p>There are some API fixes which my mentors suggested I&rsquo;ll work on those side by side I&rsquo;ll also work on the feedback and suggestions which will be given by the community in the upcoming group call and will try to finalize the interface before next week, after that I&rsquo;ll add remaining tests and docstring examples.</p>
<p>Wait for my next blog which will shed some light on the optimization part along with the integration of the interface with other parts of the library&hellip; Till then adios amigos 👋.</p>
]]></content>
        </item>
        
        <item>
            <title>Coding period: first phase part 1</title>
            <link>https://mgeeeek.github.io/posts/2020/06/coding-period-first-phase-part-1/</link>
            <pubDate>Sun, 14 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/06/coding-period-first-phase-part-1/</guid>
            <description>Community Bonding period ended on 31st May, I covered my experience with PySAL community during the CB period in my last blog. The coding period has started at the beginning of this month and we’ve already reached midway of the first phase. Through this blog, I’ll share what all I’ve been working on during these couple of weeks.
Overview of 2 Spatial Weight Objects During the community bonding period my focus was to grow my understanding of libpysal&#39;s structure, codebase, and API design paradigms.</description>
            <content type="html"><![CDATA[<p><em>Community Bonding period ended on 31st May, I covered my experience with PySAL community during the CB period in my last blog. The coding period has started at the beginning of this month and we’ve already reached midway of the first phase. Through this blog, I’ll share what all I’ve been working on during these couple of weeks.</em></p>
<h2 id="overview-of-2-spatial-weight-objects">Overview of 2 Spatial Weight Objects</h2>
<p>During the community bonding period my focus was to grow my understanding of <code>libpysal</code>'s structure, codebase, and API design paradigms. Along with this, I was looking deeply at the 2 types of spatial class objects used in PySAL namely <code>W</code> &amp; <code>WSP</code> objects which are used to construct spatial weight matrices, specifically I was understanding the logic and structure of each object and ways in which both of them are created. Lemme provides a bit overview of each object (this is a fairly basic explanation, please refer to this <a href="https://youtu.be/fc1f4MNLzdQ?t=5424">video</a> or the main <a href="https://pysal.org/libpysal/">documentation</a> of <code>libpysal</code>).</p>
<p><strong>Spatial Weights Matrix</strong>: In general, it expresses the relationship of a spatial point with its neighboring points. It can be viewed as an adjacency matrix of a weighted graph where each node is connected to other node and these connections follow a specific spatial-contiguity like rook or queen (there are other contiguities as well but these 2 are intuitive to understand).</p>
<p><strong>W object</strong>: It&rsquo;s used to construct spatial weight and represent it in the form of 2 dictionaries-</p>
<ul>
<li><code>neighbors dictionary</code>, where each key specifies a selected point, and the corresponding value is a list containing neighbors of the selected point.</li>
<li><code>weights dictionary</code>, similar to the neighbor dictionary but instead of specifying neighbors, the list contains the weight of each connection of the key to the neighbor listed in the neighbor dictionary.</li>
</ul>
<p><strong>WSP object</strong>: It is also used to construct spatial weight but unlike <code>W</code> object it represents the spatial weights in the form of a sparse matrix where each row shows the relationship of a point with every other point.</p>
<p>Constructing a <code>WSP</code> object requires fewer computation when compared to constructing a <code>W</code> object, but it does not contain the same amount of information as a <code>W</code> object. PySAL&rsquo;s statistical methods operate on these two objects and until now these two objects are mainly derived from vector data (which can be presented in the form of different structures like data frame, shapefiles).</p>
<h2 id="what-did-i-do-this-week">What did I do this week?</h2>
<p>Coming back to the coding period, in my project proposal I listed out the following tasks that I&rsquo;ll work on during first 2 weeks. Slight changes have been made in the timeline after having discussion with my mentors during CBPeriod, it was decided that <code>xarray</code> will be used for the project instead of <code>rasterio</code> because <code>xarray</code> provides a proper structure to the raster&rsquo;s metadata which makes it easy for users to manipulate and access the properties of raster file using <code>xarray.DataArray</code> object.</p>
<blockquote>
<p><em>Week 1 &amp; 2</em> (1st June - 14th June) :</p>
<ul>
<li>List out initial functionalities to be incorporated in the interface.</li>
<li>Implement necessary methods for streamlining the access to raster data using <code>rasterio</code> inside PySAL.</li>
<li>Add methods to extract extract metadata from rasters.</li>
<li>Create an optimized functionality for handling missing values in the raster data used by prototype transformational methods.</li>
<li>Investigate inner working of <code>georasters</code> methods, since some of its functionality can be improved and used for this project.</li>
<li>Discuss the proposed design of the API of interface and this will be worked upon in the next week.</li>
</ul>
</blockquote>
<p>Unfortunately, I had my exams going on during the first week of the coding period, therefore I was a little unproductive and could not completely focus on the project. During this time I set up my development environment, looked at <code>georasters</code> library, and worked on how I can convert <code>xarray.DataArray</code> to weight object.</p>
<p>My exams were over by the first week and I was able to devote more time to the project. My main task for this week was to work on prototype transformational methods that are going to be used in transforming the raster file accessed using <code>xarray</code> to <code>W</code> and <code>SW</code> objects. Along with this I also worked on converting results back to <code>xarray.Dataframe</code> object.</p>
<p>PRs made during this period:</p>
<ul>
<li><a href="https://github.com/MgeeeeK/libpysal/pull/1">Added rast2(W,SW)</a></li>
<li><a href="https://github.com/MgeeeeK/libpysal/pull/2">Added func for creating xr.dataarray</a></li>
</ul>
<p>Since I used the <code>lat2W</code> method, I noticed that the <code>W</code> object stores the neighbors in the list and for large values of rows and columns (2 arguments of the function) the computation runs out of memory, this problem will exist since the methods use eager evaluation. I plan to create an additional method which computes the dictionary values of <code>W</code> object lazily, working with generator objects is tough in this situation since some of the PySAL&rsquo;s methods require all data of <code>W</code> object in memory. This requires more time and I will see if it can be modified in a way so that the PySAL library can work with it.</p>
<h2 id="whats-next">What&rsquo;s next?</h2>
<p>During my recent project call, both mentors reviewed my work and suggested some corrections in the API and the function implementation. In the coming weeks, I have to incorporate the suggested changes and finalize both transformational methods (their APIs and return objects) and also work on the optimization part.</p>
<p>Wait for my next blog which will show the working of my contributed methods&hellip; Till then goodbye 👋.</p>
]]></content>
        </item>
        
        <item>
            <title>Community bonding period wrap-up</title>
            <link>https://mgeeeek.github.io/posts/2020/05/community-bonding-period-wrap-up/</link>
            <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/05/community-bonding-period-wrap-up/</guid>
            <description>Today marks the end of the community bonding period and the beginning of the coding period of GSoC. In this blog, I&amp;rsquo;ll share my experience with the PySAL community during the community bonding period. The community bonding period is the starting phase in the GSoC timeline which lasts for almost a month. This period is specially designed for students to get introduced to the community and to understand and learn more about the project before the coding period starts.</description>
            <content type="html"><![CDATA[<h3 id="today-marks-the-end-of-the-community-bonding-period-and-the-beginning-of-the-coding-period-of-gsoc-in-this-blog-ill-share-my-experience-with-the-pysal-community-during-the-community-bonding-period">Today marks the end of the community bonding period and the beginning of the coding period of GSoC. In this blog, I&rsquo;ll share my experience with the PySAL community during the community bonding period.</h3>
<p>The community bonding period is the starting phase in the GSoC timeline which lasts for almost a month. This period is specially designed for students to get introduced to the community and to understand and learn more about the project before the coding period starts. Additionally, students are also expected to become familiar with documentations, open-source practices, and procedures.</p>
<p>Most of my time during the community bonding period was devoted to studying the <code>libpysal</code>'s codebase thoroughly to comprehend its structure, internal functions and testing procedures, I also worked on the examples and read documentation of <code>rasterio</code> and <code>xarray</code> to understand these libraries in depth. Because of my semester getting extended by one month I was not able to dedicate more time to the project as planned earlier in my proposal, I tried to wrap up my coursework, assignments and end-sem exam preparation so that I can completely focus on the project in the coming week.</p>
<h3 id="meetings-and-progress">Meetings and Progress</h3>
<p>In total 3 projects were selected by the PySAL community for this summer. To keep the project-related meetings and interaction more efficient and productive, it was decided by the mentors to coordinate every other week with all gsoc project members and separately in the off-weeks with individual project members. During the community bonding period 3 meetings/calls occurred, one call every Friday.</p>
<ul>
<li>The first call was an introductory meeting involving all students and mentors from each project. This meeting was more about getting to know each other, everyone introduced themselves and also discussed about current state of PySAL and how community use it in their research work. Additionally, we talked about git conventions and setting up the development environment using anaconda. The first meeting was really fruitful and everyone was very friendly and welcoming.</li>
</ul>
<p>Before the next meeting, my project mentors Dani and Stefanie provided me with some additional resources related to the project. Since I&rsquo;m very new in the field of geospatial data science and GIS, I’ve been heavily involved with reading a lot of documentation and learning new things which will help me to get familiar with different statistical methods in PySAL and how they use different data structure as input.</p>
<ul>
<li>The project-specific meeting which happened one week after the first meeting only involved the mentors and student working on that project, mine was related to my project which is Raster awareness in PySAL. I updated the mentors with my proposed approach provided in the proposal, discussed the roadmap for integrating the interface to the library and talked about possible changes in the proposal, it was also cleared by the mentors that the interface with minimal changes in the core computational structure takes priority over making use of Dask since this might require a lot of research and time. The rest of our discussion was related to possible features and functionality to be included after the completion of phase 1. We also discussed about project progress tracking/management and later decided to use issue and PRs with project tag as project tracking diary.</li>
</ul>
<p>Since I&rsquo;d my exams during this week, I was not able to contribute/submit any patch related to the project. Instead, I worked and explored an efficient way to transform <code>xarray.dataArray</code> object to PySAL weight object as discussed during the last meeting. I noticed that while using the <code>Lat2W</code> function I was able to transform correctly, but building a weight object using <code>Lat2W</code> with large values of rows and columns resulted in memory overflow as it uses lists for storing the neighbors, weights, and ids in the dictionary. I&rsquo;m planning to explore this in-depth next week and push a patch related to this.</p>
<ul>
<li>In the last meeting of the community bonding period, mentors cleared some doubts which students had and discussed possible ways of project tracking and management. I also had a call with my project mentors to discuss deliverables I&rsquo;m supposed to work on during the first week of the coding period.</li>
</ul>
<p>With my exams finishing up in the mid of next week, I am looking forward to having a really productive and wonderful summer ahead, learning and contributing exciting stuff to PySAL. Till then, adios !!</p>
]]></content>
        </item>
        
        <item>
            <title>$ sudo make my summer thrilling</title>
            <link>https://mgeeeek.github.io/posts/2020/05/sudo-make-my-summer-thrilling/</link>
            <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/05/sudo-make-my-summer-thrilling/</guid>
            <description>It’s been a while since I posted or blogged about something, and the situation looks still the same&amp;hellip;
Coming to some good news&amp;hellip; My last blog ended with the submission of my GSoC proposal. From the framing of my sentence you would&amp;rsquo;ve guessed already that my GSoC2020 proposal got accepted. I wanted to tell you about this on the day I received my acceptance letter but this semester drained the soul out of me just like what happened to prison mike in prison.</description>
            <content type="html"><![CDATA[<p>It’s been a while since I posted or blogged about something, and the situation looks still the same&hellip;</p>
<p>Coming to some good news&hellip; My last blog ended with the submission of my GSoC proposal. From the framing of my sentence you would&rsquo;ve guessed already that my GSoC2020 proposal got accepted. I wanted to tell you about this on the day I received my acceptance letter but this semester drained the soul out of me just like what happened to prison mike in prison. But on the serious note, I&rsquo;ll work under NumFOCUS which is an umbrella organization supporting relatively small organizations related to scientific computing. The organization I&rsquo;ve chosen under NumFOCUS is PySAL (an abbreviation of Python Spatial Analysis Library) mainly used in geospatial data science. My project <strong><em>Raster awareness in PySAL</em></strong> proposes an interface that will support PySAL’s statistical operations on raster objects (more details can be obtained from the <a href="https://summerofcode.withgoogle.com/projects/5775104799145984">abstract</a>). The project focuses more on the core part of the library and connects with other analytical and statistical components of PySAL, which makes it really interesting and therefore I’m super excited to work on it this summer.</p>
<p>Time for me to take the leave. I hope this situation gets over as soon as possible&hellip; till then goodbye, lock yourself at home and stay safe, more importantly, wait for my next blog which will be related to my initial work on the project.</p>
]]></content>
        </item>
        
        <item>
            <title>$ blog init</title>
            <link>https://mgeeeek.github.io/posts/2020/03/blog-init/</link>
            <pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/03/blog-init/</guid>
            <description>From now on I&amp;rsquo;ll try to document all the major experiences I&amp;rsquo;ve gained involving opensource development, research work, and exciting stuff like game-theory, python-libraries, Linux-distro-kernel(this is what I come to when I&amp;rsquo;m super bored), philosophy-morality-religion(I&amp;rsquo;m being pretentious now), and most importantly trending topics in the field of AI/ML&amp;hellip; let&amp;rsquo;s leave right here cos I don&amp;rsquo;t have anything in my mind right now except for thinking about the ongoing situation because of the pandemic.</description>
            <content type="html"><![CDATA[<p>From now on I&rsquo;ll <strong>try</strong> to document all the major experiences I&rsquo;ve gained involving opensource development, research work, and exciting stuff like game-theory, python-libraries, Linux-distro-kernel(this is what I come to when I&rsquo;m super bored), philosophy-morality-religion(I&rsquo;m being pretentious now), and most importantly trending topics in the field of AI/ML&hellip; let&rsquo;s leave right here cos I don&rsquo;t have anything in my mind right now except for thinking about the ongoing situation because of the pandemic. I&rsquo;ll also submit my GSoC proposal today (hopefully I&rsquo;ll get selected&hellip; oh boy!! super excited for this summer). Till then goodbye, lock yourself at home&hellip; and stay safe.</p>
]]></content>
        </item>
        
    </channel>
</rss>
