<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Mragank Shekhar</title>
        <link>https://mgeeeek.github.io/posts/</link>
        <description>Recent content in Posts on Mragank Shekhar</description>
        <generator>Hugo -- gohugo.io</generator>
        <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
        <lastBuildDate>Sun, 30 Aug 2020 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://mgeeeek.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>GSoC2020 Project Report</title>
            <link>https://mgeeeek.github.io/posts/2020/08/gsoc2020-project-report/</link>
            <pubDate>Sun, 30 Aug 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/08/gsoc2020-project-report/</guid>
            <description>Project Details    Field Value     Project Title Raster Awareness in PySAL   Project Link https://summerofcode.withgoogle.com/projects/#5775104799145984   Organization NumFOCUS (Sub-Org: PySAL)   Mentors Stefanie Lumnitz, Dani Arribas-Bel, Levi John Wolf   Contributed Repo libpysal, splot   Working Repo Mgeeeek/libpysal   Gitter Room https://gitter.im/GSoC2020-PySAL/Raster_awareness_in_PySAL   Project Blog https://mgeeeek.github.io/tags/gsoc/    Project Description From early on, PySAL was designed with the focus of performing vector-based spatial analysis and therefore it didn&amp;rsquo;t have tools to handle input-output of large raster data.</description>
            <content type="html"><![CDATA[<h2 id="project-details">Project Details</h2>
<table>
<thead>
<tr>
<th>Field</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>Project Title</em></td>
<td>Raster Awareness in PySAL</td>
</tr>
<tr>
<td><em>Project Link</em></td>
<td><a href="https://summerofcode.withgoogle.com/projects/#5775104799145984">https://summerofcode.withgoogle.com/projects/#5775104799145984</a></td>
</tr>
<tr>
<td><em>Organization</em></td>
<td><a href="https://numfocus.org/">NumFOCUS</a> (Sub-Org: <a href="http://pysal.org/pysal">PySAL</a>)</td>
</tr>
<tr>
<td><em>Mentors</em></td>
<td><a href="https://github.com/slumnitz">Stefanie Lumnitz</a>, <a href="https://github.com/darribas">Dani Arribas-Bel</a>, <a href="https://github.com/ljwolf">Levi John Wolf</a></td>
</tr>
<tr>
<td><em>Contributed Repo</em></td>
<td><a href="https://github.com/pysal/libpysal">libpysal</a>, <a href="https://github.com/pysal/splot">splot</a></td>
</tr>
<tr>
<td><em>Working Repo</em></td>
<td><a href="https://github.com/MgeeeeK/libpysal">Mgeeeek/libpysal</a></td>
</tr>
<tr>
<td><em>Gitter Room</em></td>
<td><a href="https://gitter.im/GSoC2020-PySAL/Raster_awareness_in_PySAL">https://gitter.im/GSoC2020-PySAL/Raster_awareness_in_PySAL</a></td>
</tr>
<tr>
<td><em>Project Blog</em></td>
<td><a href="https://mgeeeek.github.io/tags/gsoc/">https://mgeeeek.github.io/tags/gsoc/</a></td>
</tr>
</tbody>
</table>
<h2 id="project-description">Project Description</h2>
<p>From early on, <code>PySAL</code> was designed with the focus of performing vector-based spatial analysis and therefore it didn&rsquo;t have tools to handle input-output of large raster data. This restricted some folks in the geospatial community to use <code>PySAL</code>'s analytical functionality over raster data. Furthermore, in recent years several geographic data organizations started releasing data in raster format which earlier came in vector format mostly because of advancement in computational capabilities and high storage availability. This led to an increase in the demand for the functionality offered by <code>PySAL</code> to make it work with raster data.</p>
<p>Taking this into consideration, my main motive was to design and implement a lightweight interface which will provide the functionality for streamlining raster data access and making it more accessible to build the data structure accepted by the analytical methods of the PySAL library (mainly <code>libpysal.weights.W/WSP</code> objects) from accessed raster data (which will be an instance of <code>xarray.DataArray</code>). Ultimately, this functionality will open up the use of analytical methods like <code>esda</code>, <code>spatial regression</code> over raster data.</p>
<p>Following were the major milestones that we planned to finish for successfully building raster interface:</p>
<ul>
<li>Design quality APIs which followed existing structure used across PySAL.</li>
<li>Deal with different properties of raster including missing data values, different data alignment, and multi-layer data.</li>
<li>Add transformational methods to support conversion to and from PySAL weights object and <code>xarray.DataArray</code> object.</li>
<li>Integrate the interface with PySAL without causing any disturbance to other parts of the library.</li>
<li>Study performance and memory efficiency of the conversion methods and optimize the interface to support computations for large raster datasets.</li>
<li>Add proper documentation, tests, and an example notebook.</li>
</ul>
<p>Since in this report we&rsquo;ll talk a lot about raster data and weights object, let&rsquo;s look at the visualization of these 2 things. Weights object in <code>PySAL</code> is a graph like structure which expresses the relationship of a spatial point with its neighboring points. We can now take a look at the visual example below:
<img src="https://user-images.githubusercontent.com/40512095/91647853-83b96b80-ea7d-11ea-8002-641ce7dc621d.png" alt="Fig. 1">
<em>This figure consist of 2 plots of weights object (which are listed below) and 2 of raster data. These weights objects were obtained using a sliced raster. We can see the relationship of spatial points is different in <code>Rook</code> and <code>Queen</code> contiguity, interface dealt with <code>nodatavals</code> while creating the weights object thats why we are seeing those empty pixels.</em><br>
<img src="https://user-images.githubusercontent.com/40512095/91647893-325dac00-ea7e-11ea-84d3-ac6882fc5231.png" alt="Fig. 2"></p>
<p><em>The development timeline for building the project was divided into 3 phases:</em></p>
<ol>
<li><em>API design phase</em></li>
<li><em>Integration phase</em></li>
<li><em>Optimization phase</em></li>
</ol>
<h3 id="api-design-phase">API design phase</h3>
<p><strong>Quick Overview</strong></p>
<p>Main goals achieved:</p>
<ul>
<li>Studied data structures provided by <code>xarray</code> and PySAL&rsquo;s <code>W</code> and <code>WSP</code> objects.</li>
<li>Created an initial skeletal implementation of the interface.</li>
<li>Iteratively designed and experimented with different APIs structures.</li>
<li>Created a working prototype of the Base Raster Interface.</li>
</ul>
<p>Pull Requests, Commits and Issues created:</p>
<ul>
<li><strong>Issue:</strong> <strong>[open]</strong> <a href="https://github.com/pysal/libpysal/issues/293#issue-629986294">Idea collection/discussion for Raster awareness project</a></li>
<li><strong>Commit:</strong> <a href="https://github.com/MgeeeeK/libpysal/commit/9eb8311605bba5f942678d7694edcc746b7ce6ee">final API with working prototype</a></li>
</ul>
<p>Blog posts published:</p>
<ul>
<li><a href="https://mgeeeek.github.io/posts/2020/06/coding-period-first-phase-part-1/">Coding Period: First Phase Part 1</a></li>
<li><a href="https://mgeeeek.github.io/posts/2020/06/coding-period-first-phase-part-2/">Coding Period: First Phase Part 2</a></li>
</ul>
<p>Contents:</p>
<ol>
<li><a href="https://github.com/MgeeeeK/GSoC2020/blob/master/gsoc2020_report_mragank_shekhar.md#io-dependency-for-accessing-raster">I/O dependency for accessing raster</a></li>
<li><a href="https://github.com/MgeeeeK/GSoC2020/blob/master/gsoc2020_report_mragank_shekhar.md#planning-main-functionality-for-the-interface">Planning main functionality for the interface</a></li>
<li><a href="https://github.com/MgeeeeK/GSoC2020/blob/master/gsoc2020_report_mragank_shekhar.md#designing-interfaces-api-weights-builder">Designing interface&rsquo;s API (<em>weights builder</em>)</a></li>
<li><a href="https://github.com/MgeeeeK/GSoC2020/blob/master/gsoc2020_report_mragank_shekhar.md#designing-interfaces-api-return-journey-to-xarraydataarray">Designing interface&rsquo;s API (<em>return journey to <code>xarray.DataArray</code></em>)</a></li>
<li><a href="https://github.com/MgeeeeK/GSoC2020/blob/master/gsoc2020_report_mragank_shekhar.md#iterative-approach-for-api-design">Iterative approach for API design</a></li>
</ol>
<p><strong>Detailed Summary</strong></p>
<ol>
<li>
<h4 id="io-dependency-for-accessing-raster">I/O dependency for accessing raster</h4>
<p>The original plan involved using <code>rasterio</code> as the main library for raster data access but from the start of the community bonding period, my mentors suggested a shift from <code>rasterio</code> to <code>xarray</code>. After going through the documentation of <code>xarray</code> it felt superior in terms of usability and accessibility as the features it provided outweighed that of <code>rasterio</code> and it also featured <code>rasterio</code> backend to access the raster data formats easily. Moreover, building the interface to work with the data structure provided by the <code>xarray</code> library made the project available to a broader audience. Therefore I continued with the <code>xarray</code> or <code>xarray.DataArray</code> to be specific, as users can easily obtain <code>xarray.DataArray</code> object from raster data format using <code>xarray</code>'s I/O functionality which can read from a variety of data formats some of them are listed below:</p>
<ul>
<li><a href="https://svn.osgeo.org/gdal/tags/gdal_1_2_5/frmts/formats_list.html">GDAL Raster Formats</a> via <code>open_rasterio</code> method.</li>
<li><a href="https://www.unidata.ucar.edu/software/netcdf/">NetCDF</a> via <code>open_dataset</code> method.</li>
</ul>
</li>
<li>
<h4 id="planning-main-functionality-for-the-interface">Planning main functionality for the interface</h4>
<p>After understanding the structure of <code>xarray.DataArray</code>, it was time to create an initial skeletal implementation of the interface which provided details of the functionality that the interface will offer. As described by Dani in this <a href="https://github.com/pysal/libpysal/issues/293#issuecomment-638446405">thread</a>:</p>
<ul>
<li>The interface would provide the functionality to create both weights object <code>libpysal.weights.W</code> &amp; <code>WSP</code> from user-provided data though <code>xarray.DataArray</code> object.</li>
<li>It should also support the return journey of the data obtained after an analytical operation on the weights object to <code>xarray.DataArray</code>.</li>
</ul>
</li>
<li>
<h4 id="designing-interfaces-api-_weights-builder_">Designing interface&rsquo;s API (<em>weights builder</em>)</h4>
<p>Once the main functionality was finalized, we jumped on to the API designing part of the project. My mentors explained how PySAL was inclined towards an object-oriented paradigm and the majority of the operations are achieved through creating an instance of a particular object using the class method and then calling the instance method. But it was also in the transitioning phase of incorporating functional programming though it was not on the top of their priority list. This motivated us to provide the functionality of direct function calling to convert <code>DataArray</code> and create respective weights object, but also implement these methods as a class method using contiguity classes (<code>Rook</code> and <code>Queen</code>).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> libpysal.weights <span style="color:#f92672">import</span> raster, Rook
<span style="color:#f92672">import</span> xarray <span style="color:#f92672">as</span> xr

<span style="color:#75715e"># Accessing raster data using xarray</span>
da <span style="color:#f92672">=</span> xr<span style="color:#f92672">.</span>open_rasterio(<span style="color:#e6db74">&#34;raster.tif&#34;</span>)

<span style="color:#75715e"># Method 1</span>
wsp1 <span style="color:#f92672">=</span> raster<span style="color:#f92672">.</span>da2WSP(da, criterion<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;rook&#34;</span>)
data1 <span style="color:#f92672">=</span> da<span style="color:#f92672">.</span>to_series()[wsp1<span style="color:#f92672">.</span>index]

<span style="color:#75715e"># Method 2</span>
wsp2 <span style="color:#f92672">=</span> Rook<span style="color:#f92672">.</span>from_xarray(da, sparse<span style="color:#f92672">=</span>True)
data2 <span style="color:#f92672">=</span> da<span style="color:#f92672">.</span>to_series()[wsp2<span style="color:#f92672">.</span>index]

data1<span style="color:#f92672">.</span>equals(data2)
</code></pre></div><pre><code>True
</code></pre>
</li>
<li>
<h4 id="designing-interfaces-api-_return-journey-to-xarraydataarray_">Designing interface&rsquo;s API (<em>return journey to <code>xarray.DataArray</code></em>)</h4>
<p>In the above example, <code>.from_xarray</code> method uses direct methods like <code>da2W</code> or <code>da2WSP</code> under the hood to build weights object from <code>xarray.DataArray</code>. A new module called <code>raster</code> was introduced to hold all the functionalities offered by the interface, it also helped in structuring the interface by separating it with other areas of the library. Just like what we saw with <code>.from_xarray</code> method, all the work related to the raster conversion is dispatched to one of the methods in the <code>raster</code> module.</p>
<p>A similar approach was taken for designing the API for the return journey. We implemented 2 types of methods:</p>
<ul>
<li><code>toDataArray</code> which can be called directly.</li>
<li>Another way was to call the instance method <code>.to_xarray</code> which provided similar functionality to the direct methods.</li>
</ul>
<p>In the later phase, <code>.to_xarray</code> method was removed due to several limitations because the structure of created weights object was different from the normal ones (more on this later), and therefore these methods would fail if the user passed the weights object not created using the interface.</p>
</li>
<li>
<h4 id="iterative-approach-for-api-design">Iterative approach for API design</h4>
<p>It took quite a few iterations to finalize the correct API of the base interface. Below are the early pull requests that I pushed to get feedbacks for the API of the transformational functions. These are far from clean as I was still experimenting with different design decisions.</p>
<ul>
<li><strong>PR:</strong> [<strong>Closed</strong>] <a href="https://github.com/MgeeeeK/libpysal/pull/1">Raster Interface v1</a></li>
<li><strong>PR:</strong> [<strong>Closed</strong>] <a href="https://github.com/MgeeeeK/libpysal/pull/3">Raster Interface v2</a></li>
<li><strong>PR:</strong> [<strong>Closed</strong>] <a href="https://github.com/MgeeeeK/libpysal/pull/4">Raster Interface v3</a></li>
</ul>
<p>Commit <a href="https://github.com/MgeeeeK/libpysal/commit/9eb8311605bba5f942678d7694edcc746b7ce6ee">9eb8311</a> was the point of the 1st phase where the majority of the APIs were locked. There were still some areas left where the community was divided particularly in structuring and naming the parameters of the methods, but these were minor issues that were solved in the later stages.</p>
</li>
</ol>
<h3 id="integration-phase">Integration phase</h3>
<p><strong>Quick Overview</strong></p>
<p>Main goals achieved:</p>
<ul>
<li>Restructured interface by aligning the methods with future weights object design.</li>
<li>Made <code>toDataArray</code> method work independent of raster metadata.</li>
<li>Added <code>KNN</code> weights support to the interface.</li>
<li>Fixed documentation, by following the NumPy-Doc convention for docstrings.</li>
<li>Added unit-tests and an example notebook.</li>
<li>Explored different ways to optimize the interface.</li>
</ul>
<p>Pull Requests, Commits and Issues created:</p>
<ul>
<li><strong>PR:</strong> <strong>[merged]</strong> <a href="https://github.com/pysal/libpysal/pull/318">Base raster interface</a></li>
<li><strong>Issue:</strong> <strong>[open]</strong> <a href="https://github.com/pysal/libpysal/issues/293#issuecomment-651636142">Idea collection/discussion for Raster awareness project</a></li>
</ul>
<p>Blog posts published:</p>
<ul>
<li><a href="https://mgeeeek.github.io/posts/2020/07/coding-period-second-phase-part-1/">Coding Period: Second Phase Part 1</a></li>
<li><a href="https://mgeeeek.github.io/posts/2020/07/coding-period-second-phase-part-2/">Coding Period: Second Phase Part 2</a></li>
</ul>
<p>Contents:</p>
<ol>
<li><a href="https://github.com/MgeeeeK/GSoC2020/blob/master/gsoc2020_report_mragank_shekhar.md#refactoring-weights-object">Refactoring weights object</a></li>
<li><a href="https://github.com/MgeeeeK/GSoC2020/blob/master/gsoc2020_report_mragank_shekhar.md#refactoring-todataarray-method-making-it-work-with-only-weights-object-and-independent-of-metadata">Refactoring <code>toDataArray</code> method</a></li>
<li><a href="https://github.com/MgeeeeK/GSoC2020/blob/master/gsoc2020_report_mragank_shekhar.md#adding-distance-based-weights-object-support">Adding distance-based weights object support</a></li>
<li><a href="https://github.com/MgeeeeK/GSoC2020/blob/master/gsoc2020_report_mragank_shekhar.md#adding-tests-documentation-example-notebook-and-finalizing-base-raster-interface">Finalzing base raster interface</a></li>
<li><a href="https://github.com/MgeeeeK/GSoC2020/blob/master/gsoc2020_report_mragank_shekhar.md#identifying-areas-to-optimize-for-adding-support-for-large-rasters">Identifying areas to optimize</a></li>
</ol>
<p><strong>Detailed Summary</strong></p>
<ol>
<li>
<h4 id="refactoring-weights-object">Refactoring weights object</h4>
<p>In the second phase, we focused on how to integrate the interface with the libpysal. One major issue related to the integration was that the output weights of the transformation methods (<code>da2W</code>/<code>da2WSP</code>) were different from the normal weights object, this was due to the extra attributes added to the weights object namely <code>attrs</code> and <code>coords</code>. This addition was implemented in the builder method to make the weights object more interactable with <code>xarray.DataArray</code> as the user will want to access the raster data easily after building the weights from the DataArray. Therefore <code>coords</code> attribute stored the coordinates indices of non-missing values in the form of <code>pandas.MultiIndex</code>, and <code>attrs</code> stored the metadata which was required when going back to the <code>xarray.DataArray</code>. This issue was addressed in the community meeting. After a detailed meeting with community members regarding the weights object, one of the major change that was proposed was to shift towards <code>WSP</code> object (here are the <a href="https://hackmd.io/Fozkz1IRQlK6GYVKI8mF9Q?both">meeting notes</a>). Additionally, the <code>id_order</code> attribute will be replaced by <code>index</code> which will contain an instance of <code>pandas.Index</code> aligned with the <code>ids</code> of the weight object.</p>
<p>This required a few changes in my existing implementation:</p>
<ul>
<li>Renamed <code>coords</code> to <code>index</code> and removed <code>attrs</code> attribute.</li>
<li>Added <code>index</code> parameter in the <code>__init__</code> method of <code>WSP</code> class.</li>
<li>Fixed creation of <code>W</code> from <code>xarray.DataArray</code> which now only relies on <code>da2WSP</code> method.</li>
</ul>
</li>
<li>
<h4 id="refactoring-todataarray-method-making-it-work-with-only-weights-object-and-independent-of-metadata">Refactoring <code>toDataArray</code> method, making it work with only weights object and independent of metadata</h4>
<p>A few of the major changes added during the second phase involved the <code>toDataArray</code> method. To make the interface more accessible we decided to only build the <code>DataArray</code> from <em>weights object</em> and <em>data values aligned to the weights object</em>. This was tricky as the weights object does not contain any information related to the missing values except the coordinates in the <code>index</code> attribute. After several tries of my own, I shifted towards the source code of the <code>pandas.MultiIndex</code>. From my earlier impressions, the data structure of <code>pandas.MultiIndex</code> was very different. Once I understood the architecture of <code>pandas.MultiIndex</code> I pushed a patch with the required changes, this patch refactored the logic and used the <code>codes</code> and <code>levels</code> property to construct all the coordinates of the <code>DataArray</code>. Commit <a href="https://github.com/MgeeeeK/libpysal/commit/e5cd4e69cbc840fb9eb229e31f126068efd476af">e5cd4e6</a> reflects the changes made targeting this method. Later <code>toDataArray</code> was split into 2 separate functions <code>w2da</code> and <code>wsp2da</code>. We can see the use of this functionality below:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> libpysal.weights <span style="color:#f92672">import</span> raster, Queen

<span style="color:#75715e"># Creating test DataArray</span>
da <span style="color:#f92672">=</span> raster<span style="color:#f92672">.</span>testDataArray(
    shape<span style="color:#f92672">=</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">56</span>, <span style="color:#ae81ff">49</span>),
    time<span style="color:#f92672">=</span>False,
    rand<span style="color:#f92672">=</span>False,
    missing_vals<span style="color:#f92672">=</span>True
)

wsp <span style="color:#f92672">=</span> Queen<span style="color:#f92672">.</span>from_xarray(
    da<span style="color:#f92672">=</span>da,
    z_value<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>,
    coords_label<span style="color:#f92672">=</span>None,
    sparse<span style="color:#f92672">=</span>True
)

<span style="color:#75715e"># Accessing data from da using index attribute</span>
data <span style="color:#f92672">=</span> da<span style="color:#f92672">.</span>to_series()[wsp<span style="color:#f92672">.</span>index]

<span style="color:#75715e"># Converting back to the DataArray</span>
da_back <span style="color:#f92672">=</span> wsp2da(data, wsp)
da_back
</code></pre></div><pre><code>&lt;xarray.DataArray (band: 1, y: 56, x: 49)&gt;
-1 211 -1 -1 -1 41 37 -1 62 -1 ... -1 171 118 135 28 151 -1 -1 -1 146
Coordinates:
* band     (band) int64 5
* y        (y) float64 66.1 66.2 66.3 66.4 66.5 ... 71.2 71.3 71.4 71.5 71.6
* x        (x) float64 92.1 92.2 92.3 92.4 92.5 ... 96.5 96.6 96.7 96.8 96.9
Attributes:
    nodatavals:  (-1,)
</code></pre>
</li>
<li>
<h4 id="adding-distance-based-weights-object-support">Adding distance-based weights object support</h4>
<p><code>Rook</code> and <code>Queen</code> contiguities were not sufficient when considered for further analysis on a raster data because <code>Rook</code> contiguity provided max 4 neighbors and <code>Queen</code> provided max 8. To tackle this, the next step was to implement distance weight builder either <code>KNN</code> or <code>DistanceBand</code>. We started with <code>KNN</code>, the initial implementation of <code>KNN</code> was very straight forward, we first converted cell centroids into points and then shipped them directly into the <code>KNN</code> builder which is based on <code>KDTree</code>. There were 2 major issues with this implementation first was very obvious as raster provided a regular lattice-like structure, <code>KNN</code> could have been more optimized since there was no need for building <code>KDTree</code>. Though the major issue was related to the ordering of the selected neighbors. Since in raster more than 2 neighbors can be equidistant from the focal point, the method inconsistently selected neighbors in a different environment. Therefore this was later removed from the project.</p>
</li>
<li>
<h4 id="adding-tests-documentation-example-notebook-and-finalizing-base-raster-interface">Adding tests, documentation, example notebook, and finalizing base raster interface</h4>
<p>Once all the components of the base raster Interface were finalized, we started working on the documentation and tests. From the beginning I followed the style of other methods inside libpysal when creating docstrings, luckily my mentors notified me early on to follow NumPy-Doc convention for docstrings. After fixing docstring we worked on adding unit-tests since we were not storing any raster dataset inside the project therefore we decided to create a <code>testDataArray</code> method (usage provided in the above example) which provided us with the different dataset to test interface correctly.</p>
<p>I also added an example notebook that introduced the API of the interface and gave a brief overview of its use-case in different scenarios. The notebook can be accessed from here:</p>
<ul>
<li><a href="https://github.com/MgeeeeK/libpysal/blob/rast_interface/notebooks/Raster_awareness_API.ipynb">Example Notebook</a></li>
</ul>
<p>Commits <a href="https://github.com/MgeeeeK/libpysal/commit/6565dd0f84768203a1c5f5cd2833cf91d6f30af3">6565dd0</a> to <a href="https://github.com/MgeeeeK/libpysal/commit/94ec4f4bc9746a235cbaa3486d06b33d76350249">94ec4f4</a> contains the majority of work finalized in the second phase. Since the main API of the base interface was finalized, I created a pull request targeting the master branch of libpysal:</p>
<ul>
<li><strong>PR:</strong> <strong>[merged]</strong> <a href="https://github.com/pysal/libpysal/pull/318">Base raster interface</a></li>
</ul>
<p><strong>Note:</strong> All my main work for the <em>first</em> and <em>second</em> phase lives inside this pull request. The commit history doesn&rsquo;t look clean as for some reason I forced pushed a few changes.</p>
</li>
<li>
<h4 id="identifying-areas-to-optimize-for-adding-support-for-large-rasters">Identifying areas to optimize for adding support for large rasters.</h4>
<p>Along with working on the interface we were also identifying and exploring the different optimization methods to optimize the interface. This thread documents list of ideas we went through during exploration.</p>
<ul>
<li><a href="https://github.com/pysal/libpysal/issues/293#issuecomment-651636142">Idea collection for Raster awareness project</a></li>
</ul>
</li>
</ol>
<h3 id="optimization-phase">Optimization phase</h3>
<p><strong>Quick Overview</strong></p>
<p>Main goals achieved:</p>
<ul>
<li>Shifted away from <code>lat2SW</code>-based weight builder.</li>
<li>Redesigned sparse matrix builder based on <code>COO_matrix</code>.</li>
<li>Numba-fied all possible methods using <code>njit</code> decorator.</li>
<li>Added multi-threaded implementation for WSP builder using <code>joblib</code>.</li>
<li>Added <code>higher_order</code> functionality to the modified weight builder.</li>
<li>Added raster-based weights object support inside <code>plot_spatial_weights</code> method in <code>splot</code>.</li>
</ul>
<p>Pull Requests, Commits and Issues created:</p>
<ul>
<li><strong>PR:</strong> <strong>[WIP]</strong> <a href="https://github.com/pysal/libpysal/pull/343">Optimized raster-based weights builder</a></li>
<li><strong>PR:</strong> <strong>[WIP]</strong> <a href="https://github.com/pysal/splot/pull/113">Added raster weights plotting functionality</a></li>
<li><strong>Issue:</strong> <strong>[open]</strong> <a href="https://github.com/pysal/libpysal/issues/328">Distance Band functionality for Raster Interface weights</a></li>
<li><strong>Issue:</strong> <strong>[open]</strong> <a href="https://github.com/pysal/splot/issues/112">plotting for <code>libpysal</code> raster functionality</a></li>
</ul>
<p>Blog posts published:</p>
<ul>
<li><a href="https://mgeeeek.github.io/posts/2020/08/coding-period-last-phase-part-1/">Coding Period: Last Phase Part 1</a>.</li>
</ul>
<p>Contents:</p>
<ol>
<li><a href="https://github.com/MgeeeeK/GSoC2020/blob/master/gsoc2020_report_mragank_shekhar.md#moving-on-from-lat2sw-based-which-uses-dia_matrix-to-new-coo_matrix-based-sparse-weight-builder">Moving on from <code>lat2SW</code>-based sparse weight builder</a></li>
<li><a href="https://github.com/MgeeeeK/GSoC2020/blob/master/gsoc2020_report_mragank_shekhar.md#optimizing-the-addition-of-higher-order-neighbors">Optimizing the addition of higher-order neighbors</a></li>
<li><a href="https://github.com/MgeeeeK/GSoC2020/blob/master/gsoc2020_report_mragank_shekhar.md#adding-visualization-support-for-the-interface">Adding visualization support for the interface</a></li>
</ol>
<p><strong>Detailed Summary</strong></p>
<ol>
<li>
<h4 id="moving-on-from-lat2sw-based-which-uses-dia_matrix-to-new-coo_matrix-based-sparse-weight-builder">Moving on from <code>lat2SW</code>-based (which uses <code>dia_matrix</code>) to new <code>coo_matrix</code>-based sparse weight builder</h4>
<p>Following the idea-collection issue, the first target for optimizing the interface was the weight builders. The existing approach used the <code>lat2SW</code> method which provided the main functionality for constructing a sparse matrix for the regular lattice. The main issue while using <code>lat2SW</code> was when we’re dealing with data consisting of missing values, in this case, boolean indexing was used for removing missing rows and columns from the created sparse matrix. The performance takes a hit due to boolean indexing of <code>csr_matrix</code> and this raised concerns for building weight objects for larger data. Memory consumption in <code>lat2SW</code> is also high due to the use of <code>lists</code> instead of <code>np.array</code>.</p>
<p>A proper explanation of this issue and how it was solved is given in this blog post.</p>
<ul>
<li><strong>Blog:</strong> <a href="https://mgeeeek.github.io/posts/2020/08/coding-period-last-phase-part-1/">Coding Period: Last Phase Part 1</a>.</li>
</ul>
<p>Also, check out this <a href="https://github.com/MgeeeeK/GSoC2020/blob/master/raster%20weights%20builder.ipynb">notebook</a> for a performance overview. These enhancements provided huge benefits both in terms of memory efficiency and faster performance. This also made the interface usable with large datasets.</p>
</li>
<li>
<h4 id="optimizing-the-addition-of-higher-order-neighbors">Optimizing the addition of higher-order neighbors</h4>
<p>In the previous section, I explained how <code>KNN</code>-based weight object was not very consistent when dealing with the raster-based data. Therefore, we decided to implement <code>higher_order</code> functionality, and 2 approaches were taken when adding the higher-order neighbors:</p>
<ul>
<li>
<p>Implementing the first approach was relatively easier than the second approach, as only a few changes were added inside the modified weights builder. An extra argument was provided which acted as a <code>threshold</code> and then using modular arithmetic conditions the algorithms added the neighbors lying inside the <code>threshold</code> radius also following contiguity criterion, though this implementation was different as it added higher order neighbors even if the lower order neighbors were missing and therefore it was more like <code>DistanceBand</code>. This thread provides some insightful discussion related to how <code>DistanceBand</code> behaves with raster data:</p>
<ul>
<li><strong>Issue:</strong> <a href="https://github.com/pysal/libpysal/issues/328">Distance Band functionality for Raster Interface</a></li>
</ul>
</li>
<li>
<p>As for the second approach, we were able to implement a correct algorithm for <code>higher_order</code> functionality inside weight builder, this algorithm used recursion to traverse nth-order neighbors or nodes because raster can be assumed as a graph. Unfortunately, we could not incorporate <code>numba</code> and <code>multi-threading</code> to the method and therefore the algorithm was very inefficient. But after some testing, we were able to add a proper algorithm for using the method that Martin suggested in this thread.</p>
<ul>
<li><strong>Issue:</strong> <a href="https://github.com/pysal/libpysal/issues/313">higher_order weights of &lt;= k</a></li>
</ul>
</li>
</ul>
<p>Since both approaches are different from each other we added <code>include_nas</code> argument which if <code>True</code>, computes weights using the first approach, and if <code>False</code> the builder uses the second approach. We can take a look at the visual example below which explains this more intuitively.
<img src="https://user-images.githubusercontent.com/40512095/91647908-7b156500-ea7e-11ea-9785-a7745bd28edc.png" alt="Fig. 3">
<em>Here we used <code>testDataArray</code> method to create a small raster data filled with random and missing values. <code>Fig. 2</code> shows the <code>Rook</code> contiguity with <code>k=1</code> which means all first-order rook neighbors are selected. <code>Fig. 3</code> shows the <code>Rook</code> contiguity with <code>k=2</code> but with <code>include_nas=False</code> which means all <code>non-missing</code> first and second-order rook neighbors are selected (this uses the second approach as described previously). <code>include_nas</code> is <code>True</code> for <code>Fig. 4</code>, we can see that in this figure all the first order neighbors are selected but while selecting second order neighbors, the method takes consideration of (missing + nonmissing) first-order neighbors.</em>
<img src="https://user-images.githubusercontent.com/40512095/91647911-7d77bf00-ea7e-11ea-844e-8dd547057a35.png" alt="Fig. 4">
After completion of these methods, a pull request was created targeting the master branch of <code>libpysal</code> which added optimized weights builder and <code>higher_order</code> functionality. This pull request describes how these approaches are different from each other:</p>
<ul>
<li><strong>[WIP]</strong> <a href="https://github.com/pysal/libpysal/pull/343">Optimized raster-based weights builder</a></li>
</ul>
</li>
</ol>
<p><strong>This marked the end of the optimization phase.</strong></p>
<ol start="3">
<li>
<h4 id="adding-visualization-support-for-the-interface">Adding visualization support for the interface.</h4>
<p>Along with optimization work, we also worked on adding the support for plotting functionality for a raster-based weight object. This required some changes inside the <code>plot_spatial_weights</code> method, mainly making it work with sparse weight objects instead of dense weight objects and adding a <code>da</code> argument for passing <code>DataArray</code> object.</p>
<ul>
<li><strong>Issue:</strong> <strong>[open]</strong> <a href="https://github.com/pysal/splot/issues/112">plotting for <code>libpysal</code> raster functionality</a></li>
<li><strong>PR:</strong> <strong>[WIP]</strong> <a href="https://github.com/pysal/splot/pull/113">Added raster weights plotting functionality</a></li>
</ul>
<p>The visualization aspect of the project is still in progress, once this pull request gets reviewed. I&rsquo;ll add more enhancements which are listed in the issue.</p>
</li>
</ol>
<h2 id="next-phase-post-gsoc">Next Phase (post-gsoc)</h2>
<ul>
<li>Since the weight object is being refactored to remove the legacy part and adopt new features from newly available libraries like <code>pandas</code> and <code>xarray</code>. I&rsquo;ll need to reflect these changes to the interface once they are incorporated into the <code>libpysal</code>.</li>
<li>Additionally, the interface once merged will be in the alpha-testing phase and I&rsquo;m expecting new bugs to pop-in which we were not able to test. Therefore I&rsquo;ll have to be available to provide the bug fixes for a few initial months of merging the interface.</li>
<li>However optimized the weights builder can be, there will be still a chance that the program will run out of memory as the raster size increases. One ambitious idea when working on the interface was related to lazily building the weights object. I did some early explorational prototyping for this part (<a href="https://github.com/MgeeeeK/libpysal/pull/7/files">[WIP] : Lazy weights object for raster interface</a>) but it&rsquo;ll require a massive change in the structure of the weights object probably a new class only supporting lazy operations. Once it is successfully implemented all the conversion and computation will be lazy which will allow users to use larger than memory rasters, albeit the computations will be slow.</li>
<li>Even though <code>xarray</code> provides great support for <code>Dask</code>, the project has not yet taken advantage of or support <code>dask</code> structures. It&rsquo;ll be a nice functionality to add to the interface in the future.</li>
</ul>
<h2 id="huge-thanks-to-pysal-community">Huge thanks to PySAL Community</h2>
<p>As a computer science undergrad this project was a breath of fresh air for me since I was relatively new to the PySAL library and the field of geospatial data science. I gained lots of experience working on this project especially working on somethings I wasn&rsquo;t completely familiar with.</p>
<p>I like to thank my mentors Stefanie, Dani, Levi for taking the time to review the prs, clearing my doubts, and providing me with valuable feedback which helped me along the way of building this project. I also appreciate the work of other community members working on this cool library.</p>
<p>I&rsquo;ll meet you in the new season of surviving 2020.</p>
<p>Mragank Shekhar</p>
]]></content>
        </item>
        
        <item>
            <title>Coding Period: Last Phase Part 1</title>
            <link>https://mgeeeek.github.io/posts/2020/08/coding-period-last-phase-part-1/</link>
            <pubDate>Mon, 17 Aug 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/08/coding-period-last-phase-part-1/</guid>
            <description>We are in the end phase of GSOC now and less than 2 weeks are remaining for finishing up our project. My last blog focused on the working of base raster interface API which is in the beta phase as it is still being reviewed by other community members. Most of my time in the first half of this phase went in optimizing the weights builder and efficiently increasing the neighbors of the focal point, let&amp;rsquo;s jump straight to the exciting stuff.</description>
            <content type="html"><![CDATA[<p><em>We are in the end phase of GSOC now and less than 2 weeks are remaining for finishing up our project. My last blog focused on the working of base raster interface API which is in the beta phase as it is still being reviewed by other community members. Most of my time in the first half of this phase went in optimizing the weights builder and efficiently increasing the neighbors of the focal point, let&rsquo;s jump straight to the exciting stuff.</em></p>
<h2 id="existing-weights-builder-design">Existing Weights Builder Design</h2>
<p>The current approach uses <code>lat2SW</code> method which provides main functionality for constructing a sparse matrix for the regular lattice. <code>lat2SW</code> calculates diagonals and offsets for building <code>scipy.sparse.dia_matrix</code> which is then converted to <code>csr_matrix</code>, this is straightforward as regular lattice does not contain missing data or any irregularities and therefore neighbors can be calculated using the predefined method for <code>rook</code> and <code>queen</code> contiguity. The main issue while using <code>lat2SW</code> was when we&rsquo;re dealing with data consisting of missing values, in this case, boolean indexing is used for removing missing rows and columns from the created sparse matrix. Performance takes a hit due to boolean indexing of <code>csr_matrix</code> and this raised concerns for building weight objects for larger data. Memory consumption in <code>lat2SW</code> is also high due to the use of <code>lists</code> instead of <code>np.array</code>.</p>
<p>This made us consider to think about another route for creating weight objects, a route where the builder only includes elements from the (non-missing) data from the beginning, unlike the approach I talked about earlier.</p>
<p>To create a matrix with only non-missing values in mind, <code>lat2SW</code>/<code>dia_matrix</code> was out of the question since it is highly oriented towards building regular lattice. Next options were to build either <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.dok_matrix.html#scipy.sparse.dok_matrix">DOK</a>, <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix">CSR/CSC</a>, or <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.html#scipy.sparse.coo_matrix">COO</a>&hellip;</p>
<ul>
<li>It was impossible (for me) to Numba-fy <code>DOK</code> builder due to its structure and without <code>numba</code> it was too slow.</li>
<li>In case of <code>CSR/CSC</code> I was not able to think of a multithreaded implementation.</li>
<li>From the start I was biased towards <code>COO</code> as its structure is quite simple, can be numba-fied, fairly easy to incorporate multithreading, and fast conversion to <code>CSR/CSC</code> matrix.</li>
</ul>
<p>And therefore I went ahead with <code>coo_matrix</code>, next part explains this in detail.</p>
<h2 id="new-weights-builder">New Weights Builder</h2>
<p>Constructing <code>coo_matrix</code> with only non-missing data was still a tricky problem since I had to know the original ids and the position ids after removing all the missing data. To solve this issue I had to create an <code>id_map</code> (1d array) of length = (missing + non-missing)data, where each ids of non-missing values contained the index values of non-missing data after removing all missing data. After this, the method uses modular arithmetic and continuous checking for creating row and col arrays only for non-missing neighbors and since this is not vectorized there was a high requirement of incorporating <code>numba</code> to the builder.</p>
<p>Up until now I never knew what <code>numba</code> really was or how it worked, luckily I was familiar with technical details of <code>cython</code> and after reading <code>numba</code> documentation I got a clear idea of how <code>numba</code> worked.</p>
<blockquote>
<p>How does Numba work?</p>
<p>Numba reads the Python bytecode for a decorated function and combines this with information about the types of the input arguments to the function. It analyzes and optimizes your code, and finally uses the LLVM compiler library to generate a machine code version of your function, tailored to your CPU capabilities. This compiled version is then used every time your function is called.</p>
</blockquote>
<p>Since the new sparse matrix implementation involved traversing a huge for loop, <code>numba</code> substantially improved the performance of builder, please check <a href="https://github.com/MgeeeeK/GSoC2020/blob/master/raster%20weights%20builder.ipynb">this notebook</a> for performance overview. It can be seen that the new method is much better in terms of both scalability and efficiency, we can also see that without numba the new method will be of no use as the difference is of night and day. Now if you thought that this is it (if you&rsquo;re someone who is not familiar with the project already) then nope, there is one more level to make this more efficient which is through parallel processing.</p>
<h2 id="parallel-implementation">Parallel Implementation</h2>
<p>For making the program run parallelly there was a need for restructuring how it handles passed data, we&rsquo;ve to divide the workload into smaller workloads which will run on each thread or a process simultaneously, after all the workloads are finished we&rsquo;ll combine all the results thus obtaining desired output. Luckily this <a href="https://github.com/pysal/esda/pull/116">pr #116</a> helped me a lot to understand proper implementation for making weights builder work parallelly. Let&rsquo;s go through the implementation:</p>
<ul>
<li>There are 3 main components to build parallel pipeline, first is the base compute method which in our case is numbafied method that generates <code>rows</code> and <code>cols</code> array, second is the method which will divide our data for smaller workload, and third is the main method which will be called to initiate the parallel pipeline, this method creates the parallel instance and then combines the output of each instance into the desired results.</li>
<li>First step in my case was to analyze the arguments that the new weight builder needed, which are 2 arrays and 4 static variables. <code>id_map</code> and <code>ids</code> are the 2 arrays where <code>ids</code> contained the index of non-missing data (<code>id_map</code> is already explained earlier). We needed complete <code>id_map</code> to build <code>rows</code> and <code>cols</code> arrays so there was no need of modifying it, but to divide workload we sliced the <code>ids</code> array into n equal parts, where n is the number of workloads we have to divide (typically n this is equal to the total number of threads in our computer).</li>
<li>We can use an iterator or a generator to create equal parts of <code>ids</code>. Let&rsquo;s say if the length of our <code>ids</code> array is 100 and the value of <code>n</code> is 4 then the generator we&rsquo;ll generate 4 chunks of <code>ids</code> array. In this case, we created an array which consisted of starting index of each chunk in this case it consists <code>[0, 25, 50, 75]</code>.
<ul>
<li>chunk1 -&gt; ids[0:25]</li>
<li>chunk2 -&gt; ids[25:50]</li>
<li>chunk2 -&gt; ids[50:75]</li>
<li>chunk2 -&gt; ids[75:100]</li>
</ul>
</li>
<li>After creating the required chunk generator, we implemented the main method we use delayed function to create n lists of workload for each parallel instance and each <code>ids</code> argument in this list consisted of the <code>ids_chunk</code> calculated in the second step. After the processing is finished we obtained a tuple containing the output of n instances.</li>
<li>The final step is to assemble and combine the parallel output into our desired results which in this case was merging n <code>rows</code> and n <code>cols</code>.</li>
</ul>
<p>Now there are different ways to parallelize the workloads. <code>joblib</code> offers 3 backends <code>loky</code>, <code>threading</code>, and <code>multiprocessing</code>. This opens up the discussion of threads-based vs process-based parallelism:</p>
<blockquote>
<p>Thread-based parallelism vs Process-based parallelism</p>
<p>By default <code>joblib.Parallel</code> uses the <code>loky</code> backend module to start separate Python worker processes to execute tasks concurrently on separate CPUs. This is a reasonable default for generic Python programs but can induce a significant overhead as the input and output data need to be serialized in a queue for communication with the worker processes (see Serialization &amp; Processes).</p>
<p>When you know that the function you are calling is based on a compiled extension that releases the Python Global Interpreter Lock (GIL) during most of its computation then it is more efficient to use threads instead of Python processes as concurrent workers. For instance, this is the case if you write the CPU intensive part of your code inside a with nogil block of a Cython function.</p>
</blockquote>
<p><a href="https://github.com/pysal/esda/pull/116">pr #116</a> uses <code>loky</code> backend and therefore I started with the same. But in the case of rasters the memory footprint of using <code>loky</code> backend was huge, combined with worse performance than the single-threaded approach I had to think of another way. I stumbled upon <code>threading</code> backend but this required me to release the Python Global Interpreter Lock which can be risky otherwise threads will not run parallely (here I ask you to <a href="https://www.google.com/search?q=python+release+gil+disadvantages">google</a> those risks, this blog has already become enormous). But in the current builder all the arguments are static and are not bound to change during the computations and therefore I continued with <code>threading</code> backend and since the compute method uses <code>numba</code> it was relatively easy to release the <code>gil</code> through <code>nogil=True</code> argument inside the decorator.</p>
<p>The multi-threading approach resulted in a small performance boost as the main bottleneck was still constructing <code>COO_matrix</code> and then converting it to <code>csr_matrix</code>. But overall this was superior to the <code>lat2SW</code> approach in every way, here is the <a href="https://github.com/MgeeeeK/GSoC2020/blob/master/.ipynb_checkpoints/optimized_weight_builder-checkpoint.ipynb">link</a> to the second notebook for performance overview. I&rsquo;ve also provided the link to the <code>numba</code> and <code>joblib</code> documentation for a better understanding of the subject.</p>
<h2 id="additional-resources">Additional resources</h2>
<ol>
<li><a href="https://numba.pydata.org/numba-doc/latest/user/5minguide.html">A ~5-minute guide to Numba</a></li>
<li><a href="https://joblib.readthedocs.io/en/latest/parallel.html">Embarrassingly parallel for loops</a></li>
</ol>
<h2 id="whats-next">What&rsquo;s next?</h2>
<p>I&rsquo;m glad that I was able to become part of the PySAL community, I&rsquo;ve developed in so many aspects during GSoC. The program is about to end in 2 weeks, I&rsquo;m still working on efficiently increasing the neighbors in the weights object alongside visualization part of the raster interface.</p>
<p>Wait for my last blog which will be little light and casual, and will tell about what is coming in future&hellip; goodbye moonmen 👋.</p>
]]></content>
        </item>
        
        <item>
            <title>Coding Period: Second Phase Part 2</title>
            <link>https://mgeeeek.github.io/posts/2020/07/coding-period-second-phase-part-2/</link>
            <pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/07/coding-period-second-phase-part-2/</guid>
            <description>Phase two of GSoC2020 is over, this blog is little late cos my laptop&amp;rsquo;s HDD died and I was unable to save my Hugo environment. Overall the summer has been really productive and the API design of the interface is finally reached beta period, let&amp;rsquo;s look at the progress.
Final API of the Interface After several weeks of coding, design discussions, and code review, phase 1 of my project which consisted of designing API and all the functionality for the base raster interface is completed.</description>
            <content type="html"><![CDATA[<p><em>Phase two of GSoC2020 is over, this blog is little late cos my laptop&rsquo;s HDD died and I was unable to save my Hugo environment. Overall the summer has been really productive and the API design of the interface is finally reached beta period, let&rsquo;s look at the progress.</em></p>
<h2 id="final-api-of-the-interface">Final API of the Interface</h2>
<p>After several weeks of coding, design discussions, and code review, phase 1 of my project which consisted of designing API and all the functionality for the base raster interface is completed. In the last couple of weeks, I had to work on refactoring the methods to align them with the future design of the weights object, along with this there were some new test cases that I had to deal with as my earlier approach was focused only on <code>GDAL raster formats</code> and <code>open_rasterio</code> method which restricted the interface from being used with other datasets like <code>NetCDF</code> and therefore I&rsquo;d to work on refactoring and thinking what will be the best way to introduce this functionality in the interface.</p>
<p>These new changes were finalized after project meeting with my mentors, they explained that it&rsquo;ll be ideal if the support for other datasets is extended and the methods could be made more generalized. For this, a parameter <code>dims</code> was added to the weight builders, this argument will accept a dictionary, if dimensions of the <code>DataArray</code> does not match default dimensions which are <code>['band', 'time', 'lat', 'y', 'lon', 'x']</code>.</p>
<p>e.g. <code>dims</code> dictionary:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># none of the dimension belong to the default dimension list</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> da<span style="color:#f92672">.</span>dims                  
(<span style="color:#e6db74">&#39;year&#39;</span>, <span style="color:#e6db74">&#39;height&#39;</span>, <span style="color:#e6db74">&#39;width&#39;</span>)
<span style="color:#75715e"># dimension values should be properly aligned with the following keys</span>
<span style="color:#f92672">&gt;&gt;&gt;</span> dims <span style="color:#f92672">=</span> {
        <span style="color:#e6db74">&#34;layer&#34;</span>: <span style="color:#e6db74">&#34;year&#34;</span>,
        <span style="color:#e6db74">&#34;lat&#34;</span>: <span style="color:#e6db74">&#34;height&#34;</span>,
        <span style="color:#e6db74">&#34;lon&#34;</span>: <span style="color:#e6db74">&#34;width&#34;</span>
    }
</code></pre></div><p>After adding new fixes, I worked on adding documentation and tests which took me a while to get my head around. After a few iterations of code review by my mentors, they notified me that I need to follow the <code>NumPy</code> doc convention for adding docstring. And in the last week of phase 2, I was able to finalize most of the work, you can check this pr which itself documents my progress in the second phase.</p>
<ul>
<li><a href="https://github.com/pysal/libpysal/pull/318">[WIP] : Base Raster Interface</a></li>
</ul>
<p>I&rsquo;ve provided an example notebook, which will try to cover the functionality offered by the raster interface.</p>
<h2 id="example-notebook-for-raster-awareness-api">Example Notebook for Raster awareness API</h2>
<p>This notebook will give an overview of newly developed raster interface. We&rsquo;ll cover
basic usage of the functionality offered by the interface which mainly involves:</p>
<ol>
<li>converting <code>xarray.DataArray</code> object to the PySAL&rsquo;s weights object (<code>libpysal.weights.W</code>/<code>WSP</code>).</li>
<li>going back to the <code>xarray.DataArray</code> from weights object.</li>
</ol>
<p>using different datasets:</p>
<ul>
<li>with missing values.</li>
<li>with multiple layers.</li>
<li>with non conventional dimension names.</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">%</span>matplotlib inline

<span style="color:#f92672">from</span> libpysal.weights <span style="color:#f92672">import</span> Rook, Queen, KNN
<span style="color:#f92672">from</span> libpysal.weights <span style="color:#f92672">import</span> raster
<span style="color:#f92672">import</span> libpysal <span style="color:#f92672">as</span> lp
<span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> xarray <span style="color:#f92672">as</span> xr
<span style="color:#f92672">import</span> pandas <span style="color:#f92672">as</span> pd
<span style="color:#f92672">from</span> esda <span style="color:#f92672">import</span> Moran_Local
</code></pre></div><h3 id="loading-data">Loading Data</h3>
<p><em>The interface only accepts <code>xarray.DataArray</code></em>, this can be easily obtained from raster data
format using <code>xarray</code>'s I/O functionality which can read from a variety of data formats some of them are listed below:</p>
<ul>
<li><a href="https://svn.osgeo.org/gdal/tags/gdal_1_2_5/frmts/formats_list.html">GDAL Raster Formats</a> via <code>open_rasterio</code> method.</li>
<li><a href="https://www.unidata.ucar.edu/software/netcdf/">NetCDF</a> via <code>open_dataset</code> method.</li>
</ul>
<p>In this notebook we&rsquo;ll work with <code>NetCDF</code> and <code>GeoTIFF</code> data.</p>
<h4 id="using-local-netcdf-dataset">Using local <code>NetCDF</code> dataset</h4>
<p>In this small example we&rsquo;ll build <code>KNN</code> distance weight object using a local <code>NetCDF</code> dataset with different dimensions names which doesn&rsquo;t belong to the default list of dimensions.</p>
<p>We&rsquo;ll also see how to speed up the reverse journey (from weights object to <code>DataArray</code>) by passing prebuilt <code>coords</code> and <code>attrs</code> to <code>w2da</code> method.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># After loading netCDF dataset we obtained a xarray.Dataset object</span>
ds <span style="color:#f92672">=</span> xr<span style="color:#f92672">.</span>open_dataset(<span style="color:#e6db74">&#39;ECMWF_ERA-40_subset.nc&#39;</span>)
<span style="color:#75715e"># This Dataset object containes several data variables    </span>
<span style="color:#66d9ef">print</span>(ds)                                         
</code></pre></div><pre><code>&lt;xarray.Dataset&gt;
Dimensions:    (latitude: 73, longitude: 144, time: 62)
Coordinates:
  * longitude  (longitude) float32 0.0 2.5 5.0 7.5 ... 350.0 352.5 355.0 357.5
  * latitude   (latitude) float32 90.0 87.5 85.0 82.5 ... -85.0 -87.5 -90.0
  * time       (time) datetime64[ns] 2002-07-01T12:00:00 ... 2002-07-31T18:00:00
Data variables:
    tcw        (time, latitude, longitude) float32 ...
    tcwv       (time, latitude, longitude) float32 ...
    lsp        (time, latitude, longitude) float32 ...
    cp         (time, latitude, longitude) float32 ...
    msl        (time, latitude, longitude) float32 ...
    blh        (time, latitude, longitude) float32 ...
    tcc        (time, latitude, longitude) float32 ...
    p10u       (time, latitude, longitude) float32 ...
    p10v       (time, latitude, longitude) float32 ...
    p2t        (time, latitude, longitude) float32 ...
    p2d        (time, latitude, longitude) float32 ...
    e          (time, latitude, longitude) float32 ...
    lcc        (time, latitude, longitude) float32 ...
    mcc        (time, latitude, longitude) float32 ...
    hcc        (time, latitude, longitude) float32 ...
    tco3       (time, latitude, longitude) float32 ...
    tp         (time, latitude, longitude) float32 ...
Attributes:
    Conventions:  CF-1.0
    history:      2004-09-15 17:04:29 GMT by mars2netcdf-0.92
</code></pre>
<p>Out of 17 data variables we&rsquo;ll use <code>p2t</code> for our analysis. This will give us our desired <code>DataArray</code> object <code>da</code>, we will further group <code>da</code> by day, taking average over the <code>time</code> dimension.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># this will give us the required DataArray with p2t (2 metre temperature) data variable</span>
da <span style="color:#f92672">=</span> ds[<span style="color:#e6db74">&#34;p2t&#34;</span>]  
da <span style="color:#f92672">=</span> da<span style="color:#f92672">.</span>groupby(<span style="color:#e6db74">&#39;time.day&#39;</span>)<span style="color:#f92672">.</span>mean()
<span style="color:#66d9ef">print</span>(da<span style="color:#f92672">.</span>dims)
</code></pre></div><pre><code>('day', 'latitude', 'longitude')
</code></pre>
<p><strong>Weight builders (<code>from_xarray</code>, <code>da2W</code>, <code>da2WSP</code>) can recognise dimensions belonging to this list <code>[band, time, lat, y, lon, x]</code>, if any of the dimension in the <code>DataArray</code> does not belong to the mentioned list then we need to pass a dictionary (specifying that dimension’s name) to the weight builder. We can see that the none of dimensions of <code>da</code> matches with the default dimensions (<code>[band, time, lat, y, lon, x]</code>)</strong></p>
<p>This means we have to create a dictionary mentioning the dimensions and ship it to weight builder, similar to our last example.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">dims <span style="color:#f92672">=</span> {}
dims[<span style="color:#e6db74">&#34;lat&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;latitude&#34;</span>
dims[<span style="color:#e6db74">&#34;lon&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;longitude&#34;</span>
dims[<span style="color:#e6db74">&#34;layer&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;day&#34;</span>
w_knn <span style="color:#f92672">=</span> KNN<span style="color:#f92672">.</span>from_xarray(da, layer<span style="color:#f92672">=</span><span style="color:#ae81ff">13</span>, dims<span style="color:#f92672">=</span>dims, k<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># we can derive the data from DataArray using index attribute</span>
data <span style="color:#f92672">=</span> da<span style="color:#f92672">.</span>to_series()[w_knn<span style="color:#f92672">.</span>index]  
</code></pre></div><p>We can now speed up <code>w2da</code> by passing <code>coords</code> from the existing <code>DataArray</code> <code>da</code> which we used earlier.</p>
<p>Along with <code>coords</code> we can also pass <code>attrs</code> of the same <code>DataArray</code> this will help <code>w2da</code> to retain all the properties of original <code>DataArray</code>.</p>
<p>Let&rsquo;s compare the <code>DataArray</code> returned by <code>w2da</code> and original <code>DataArray</code>. For this we&rsquo;ll ship the derived data straight to <code>w2da</code> without any statistical analysis.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">da1 <span style="color:#f92672">=</span> raster<span style="color:#f92672">.</span>w2da(data, w_knn, attrs<span style="color:#f92672">=</span>da<span style="color:#f92672">.</span>attrs, coords<span style="color:#f92672">=</span>da[<span style="color:#ae81ff">12</span>:<span style="color:#ae81ff">13</span>]<span style="color:#f92672">.</span>coords)
<span style="color:#75715e"># method to compare 2 DataArray, if true then w2da was successfull</span>
xr<span style="color:#f92672">.</span>DataArray<span style="color:#f92672">.</span>equals(da[<span style="color:#ae81ff">12</span>:<span style="color:#ae81ff">13</span>], da1)  
</code></pre></div><pre><code>True
</code></pre>
<h4 id="using-local-geotiff-dataset">Using local <code>GeoTIFF</code> dataset</h4>
<p>Up until now we&rsquo;ve only played with <code>netCDF</code> datasets but in this example we&rsquo;ll use a <code>raster.tif</code> file to see how interface interacts with it. We&rsquo;ll also see how these methods handle missing data.</p>
<p>Unlike earlier we&rsquo;ll use weight builder methods from <code>raster.py</code>, which we can call directly. Just a reminder that <code>from_xarray</code> uses methods from <code>raster.py</code> and therefore only difference exists in the API.</p>
<p>To access GDAL Raster Formats xarray offers <code>open_rasterio</code> method which uses <code>rasterio</code> as backend. It loads metadata, coordinate values from the raster file and assign them to the <code>DataArray</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Loading raster data with missing values</span>
da <span style="color:#f92672">=</span> xr<span style="color:#f92672">.</span>open_rasterio(<span style="color:#e6db74">&#39;lux_ppp_2019.tif&#39;</span>)
<span style="color:#66d9ef">print</span>(da)
</code></pre></div><pre><code>&lt;xarray.DataArray (band: 1, y: 880, x: 940)&gt;
[827200 values with dtype=float32]
Coordinates:
  * band     (band) int64 1
  * y        (y) float64 50.18 50.18 50.18 50.18 ... 49.45 49.45 49.45 49.45
  * x        (x) float64 5.745 5.746 5.747 5.747 ... 6.525 6.526 6.527 6.527
Attributes:
    transform:      (0.0008333333297872345, 0.0, 5.744583325, 0.0, -0.0008333...
    crs:            +init=epsg:4326
    res:            (0.0008333333297872345, 0.0008333333295454553)
    is_tiled:       0
    nodatavals:     (-99999.0,)
    scales:         (1.0,)
    offsets:        (0.0,)
    AREA_OR_POINT:  Area
</code></pre>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># we can see that the DataArray contains missing values.</span>
da<span style="color:#f92672">.</span>where(da<span style="color:#f92672">.</span>values<span style="color:#f92672">&gt;</span>da<span style="color:#f92672">.</span>attrs[<span style="color:#e6db74">&#34;nodatavals&#34;</span>][<span style="color:#ae81ff">0</span>])<span style="color:#f92672">.</span>plot() 
</code></pre></div><pre><code>&lt;matplotlib.collections.QuadMesh at 0x7f27287a3550&gt;
</code></pre>

    <img src="/images/Raster_awareness_API_29_1.png"  alt="png"  class="center"  />


<p>We&rsquo;ll look at how weight builders handle missing values. Firstly we&rsquo;ll slice the <code>DataArray</code> to reduce overall size for easier visualization.</p>
<p>This time we&rsquo;ll create <code>WSP</code> object using <code>da2WSP</code> method inside <code>raster.py</code>. Since our DataArray is single banded and all of its dimensions belong to the default list, we&rsquo;ve to only ship the DataArray to the <code>da2WSP</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Slicing the dataarray</span>
da_s <span style="color:#f92672">=</span> da[:, <span style="color:#ae81ff">330</span>:<span style="color:#ae81ff">340</span>, <span style="color:#ae81ff">129</span>:<span style="color:#ae81ff">139</span>]
w_queen <span style="color:#f92672">=</span> raster<span style="color:#f92672">.</span>da2WSP(da_s)  <span style="color:#75715e"># default contiguity is queen</span>
w_rook <span style="color:#f92672">=</span> raster<span style="color:#f92672">.</span>da2WSP(da_s, <span style="color:#e6db74">&#34;rook&#34;</span>)
</code></pre></div><p>After plotting both contiguities and sliced <code>DataArray</code>, we can see that the missing values are ignored by the <code>da2WSP</code> method and only indices of non missing values are stored in <code>index</code> attribute of <code>WSP</code> object.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">f,ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>,figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">4</span><span style="color:#f92672">*</span><span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">4</span>), subplot_kw<span style="color:#f92672">=</span>dict(aspect<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;equal&#39;</span>))
da_s<span style="color:#f92672">.</span>where(da_s<span style="color:#f92672">.</span>values<span style="color:#f92672">&gt;</span>da_s<span style="color:#f92672">.</span>attrs[<span style="color:#e6db74">&#34;nodatavals&#34;</span>][<span style="color:#ae81ff">0</span>])<span style="color:#f92672">.</span>plot(ax<span style="color:#f92672">=</span>ax[<span style="color:#ae81ff">0</span>])
ax[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;Sliced raster&#34;</span>)
plot_spatial_weights(w_rook, da_s, ax<span style="color:#f92672">=</span>ax[<span style="color:#ae81ff">1</span>])
ax[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;Rook contiguity&#34;</span>)
plot_spatial_weights(w_queen, da_s, ax<span style="color:#f92672">=</span>ax[<span style="color:#ae81ff">2</span>])
ax[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;Queen contiguity&#34;</span>)
plt<span style="color:#f92672">.</span>show()
</code></pre></div>
    <img src="/images/Raster_awareness_API_33_0.png"  alt="png"  class="center"  />


<h3 id="additional-resources">Additional resources</h3>
<ol>
<li><a href="http://xarray.pydata.org/en/stable/io.html">Reading and writing files using Xarray</a></li>
<li><a href="http://xarray.pydata.org/en/stable/data-structures.html">Xarray Data Structures</a></li>
</ol>
<h2 id="whats-next">What&rsquo;s next?</h2>
<p>My first deliverable is almost complete (few bugs here and there stills exists and beta testing is still going on). This coding phase is dedicated towards optimizing and integration of raster interface. Regarding optimization, I&rsquo;ve succesfully built a faster raster weight builder using <code>numba</code> and <code>COO_matrix</code>, I&rsquo;m working on the multicore implementation for the same. After finishing high performant weight builder, I&rsquo;ll look into efficiently increasing the neighbors in the weights object.</p>
<p>Find out what happens next in the episode of GSoC2020&hellip; until then bye-bye 👋.</p>
]]></content>
        </item>
        
        <item>
            <title>Coding Period: Second Phase Part 1</title>
            <link>https://mgeeeek.github.io/posts/2020/07/coding-period-second-phase-part-1/</link>
            <pubDate>Fri, 17 Jul 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/07/coding-period-second-phase-part-1/</guid>
            <description>Phase 1 of the coding period has already completed and we&amp;rsquo;ve had almost reached the midpoint of the coding period. This blog will provide a short update of the work done in the last couple of weeks.
API Status At the end of Phase 1, there were some bug fixes and API changes that my mentors suggested, these were minor changes that were quickly included in the project in the following week.</description>
            <content type="html"><![CDATA[<p><em>Phase 1 of the coding period has already completed and we&rsquo;ve had almost reached the midpoint of the coding period. This blog will provide a short update of the work done in the last couple of weeks.</em></p>
<h2 id="api-status">API Status</h2>
<p>At the end of Phase 1, there were some bug fixes and API changes that my mentors suggested, these were minor changes that were quickly included in the project in the following week. After adding these changes the base raster interface was ready to get reviewed by the PySAL community and one of the main discussion topic was related to the attribute situation that the raster project was facing. After a detailed meeting with community members regarding the <code>W</code> object&hellip; which was really interesting as the conversation deep dived into the history and the API decisions went behind the creation of <code>W</code> object which is very core to the PySAL library as most methods are built around it, you can checkout these <a href="https://hackmd.io/Fozkz1IRQlK6GYVKI8mF9Q?both">meeting notes</a> anyway&hellip; one of the major change that was proposed is to shift towards <code>WSP</code> object (go through my last blogs to learn more about these 2 objects) additionally <code>id_order</code> attribute will be replaced by <code>index</code> which will contain instance of <code>pandas.Index</code> aligned with the ids of the weight object.
This required some changes in my existing implementation, since the API was finalized I created a pull request which can be accessed here -</p>
<ul>
<li><a href="https://github.com/pysal/libpysal/pull/318">[WIP] : Base Raster Interface</a></li>
</ul>
<p>I also started working on unit tests and documentation to go along with the interface. When I look back at my proposal I feel like I underestimated the first phase, this which was a mistake from my side as I never thought how much time it goes behind the designing the API.</p>
<h2 id="optimization-phase">Optimization Phase</h2>
<p>In the proposed timeline, after successfully delivering the base raster interface with complete and finalized API I planned to work on the optimization phase. Since the API was almost finished I started to think about possible solutions to improve the <em>performance</em> and <em>scalability</em> of the current methods. After my project related meeting with my mentors, we finalized several optimization related ideas that can be incorporated in the project. You can look into this issue which contains discussion related to the optimization phase -</p>
<ul>
<li><a href="https://github.com/pysal/libpysal/issues/293">Idea collection/discussion for Raster awareness project</a></li>
</ul>
<p>One of the more ambitious ideas was to create a <em>lazy graph mixin</em>, since a raster can be expressed as a regular lattice, we can build the weight object <em>on-the-fly</em> with only some information about raster in the memory. I explored this idea and pushed a <em>prototype</em> object which calculates neighbors of a given id lazily, it is still far from the real solution but it will help me to think more about this concept as it will significantly help the interface to work even on low memory.</p>
<ul>
<li><a href="https://github.com/MgeeeeK/libpysal/pull/7">[WIP] : Lazy weights object for raster interface</a></li>
</ul>
<p>Right now the top priority is to build the weights object with only <em>non-missing values</em> as the current approach builds a regular lattice and then removes the missing values using boolean masking which is computationally quite expensive. Along with this, I&rsquo;ve to think about how I can utilize almighty <code>numba</code> to further improve the performance of the builders, I&rsquo;ve experimented with this to improve the existing solution you can check the implementation here -</p>
<ul>
<li><a href="https://github.com/MgeeeeK/libpysal/pull/6">[WIP]: Raster optimization phase</a></li>
</ul>
<p>Once the base interface is merged I&rsquo;ll work on these solutions and explore more ways to optimize the interface.</p>
<h2 id="whats-next">What&rsquo;s next?</h2>
<p>Currently, my main focus is to complete the base raster interface by adding tests and documentation. After that, I&rsquo;ll look into ongoing optimization of the current methods and later explore ideas related to integrating the interface with other library components.</p>
<p>Goodbye 👋 fellow human, will meet you in the next blog.</p>
]]></content>
        </item>
        
        <item>
            <title>Coding Period: First Phase Part 2</title>
            <link>https://mgeeeek.github.io/posts/2020/06/coding-period-first-phase-part-2/</link>
            <pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/06/coding-period-first-phase-part-2/</guid>
            <description>Phase 1 of the coding period is about to get over and 2 weeks have already passed since I gave an update on my GSoC project. As per my last blog, I successfully implemented the prototype transformation methods of the base interface, let’s look at the developments happened after the first 2 weeks.
Progress on the Project The main goal of the first phase was to implement and finalize the base raster interface, in other words, I had to incorporate all methods which can be utilized to make the transformations from xarray.</description>
            <content type="html"><![CDATA[<p><em>Phase 1 of the coding period is about to get over and 2 weeks have already passed since I gave an update on my GSoC project. As per my last <a href="https://mgeeeek.github.io/posts/2020/06/coding-period-first-phase-part-1/">blog</a>, I successfully implemented the prototype transformation methods of the base interface, let’s look at the developments happened after the first 2 weeks.</em></p>
<h2 id="progress-on-the-project">Progress on the Project</h2>
<p>The main goal of the first phase was to implement and finalize the base raster interface, in other words, I had to incorporate all methods which can be utilized to make the transformations from <code>xarray.DataArray</code> to both weight objects of PySAL (explained in my previous blog) and convert data back to <code>xarray.DataArray</code>. In the first 2 weeks of the coding period, we discussed the potential API of these methods and I worked on the prototype functions (this pr shows the initial prototype).</p>
<p>The proposed timeline in the project proposal for last 2 weeks is listed below:</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> Design the Uniform API which will aid in building the interface and in integrating well across PySAL library.</li>
<li><input checked="" disabled="" type="checkbox"> Finalize the logic of the transformational methods based on eager evaluation.</li>
<li><input disabled="" type="checkbox"> Add additional functionality to convert raster data straight to <code>Geo/Pandas Dataframe</code></li>
<li><input checked="" disabled="" type="checkbox"> Implement other required raster utility methods.</li>
<li><input checked="" disabled="" type="checkbox"> Create utility functions that will be required for reshaping and aligning the raster data with spatial weights matrix.</li>
<li><input checked="" disabled="" type="checkbox"> Create a functionality for processing the outputs from PySAL to write them out to <code>rasterio</code> object. (<em><code>rasterio</code> was replaced by <code>xarray</code>, read last blog for the reason</em>)</li>
</ul>
<p>Most of the tasks were achieved during this period except 3rd one which is not in our plan currently but I will look into it in the later stage.</p>
<h2 id="new-api-designenhancements">New API Design/Enhancements</h2>
<p>After several discussions with my mentors it was decided that the better way to present the transformational methods to the user is by using class methods through the contiguity classes (<code>Rook</code> and <code>Queen</code> for now). This required some modification in the existing weights object, current approach adds one additional attribute to store the coordinates of non-missing values (this will be further discussed with the rest of the community during this weeks group call). After finalizing the base interface by adding necessary changes targeting the community feedback I&rsquo;ll add the tests.</p>
<h2 id="example-notebook-for-raster-interface">Example Notebook for Raster Interface</h2>
<p>This notebook will provide an overview of ways we can use newly added raster interface to operate on raster data.</p>
<p><a href="https://mybinder.org/v2/gh/MgeeeeK/GSoC2020/master?filepath=gsoc_phase_1_raster_interface.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt="Binder"></a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">%</span>matplotlib inline

<span style="color:#f92672">from</span> libpysal.weights <span style="color:#f92672">import</span> Rook, Queen
<span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> xarray <span style="color:#f92672">as</span> xr
<span style="color:#f92672">from</span> esda <span style="color:#f92672">import</span> Moran_Local
</code></pre></div><pre><code>/data/GSoC/libpysal/libpysal/weights/util.py:20: UserWarning: geopandas not available. Some functionality will be disabled.
  warn('geopandas not available. Some functionality will be disabled.')
</code></pre>
<p>Currently each method inside this interface only accepts <code>xarray.DataArray</code> as input, let&rsquo;s read in some data using <code>open_rasterio()</code> method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Multiband band raster data with no missing values</span>
da1 <span style="color:#f92672">=</span> xr<span style="color:#f92672">.</span>open_rasterio(<span style="color:#e6db74">&#39;HARV_RGB_Ortho.tif&#39;</span>)
<span style="color:#75715e"># Slicing the dataarray</span>
da1 <span style="color:#f92672">=</span> da1[:, <span style="color:#ae81ff">600</span>:<span style="color:#ae81ff">700</span>, <span style="color:#ae81ff">700</span>:<span style="color:#ae81ff">800</span>] 
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Ploting only first band of the da</span>
da1[:<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>plot()
</code></pre></div>
    <img src="/images/Untitled_4_1.png"  alt="png"  class="center"  />


<p>After accessing the raster data we will create weights object using a method called <code>from_xarray</code> from Rook class</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Let&#39;s check the method first</span>
help(Rook<span style="color:#f92672">.</span>from_xarray)
</code></pre></div><pre><code>Help on method from_xarray in module libpysal.weights.contiguity:

from_xarray(da, band=None, sparse=False, **kwargs) method of builtins.type instance
    Construct a weights object from a xarray.DataArray object 
    
    Parameters
    ----------
    da         : xarray.DataArray
                raster file accessed using xarray.open_rasterio method
    band       : int
                select band for raster with multiple bands
    sparse     : boolean
                type of weight object. Default is dense. For sparse, sparse = True
    **kwargs   : keyword arguments
                optional arguments for :class:`pysal.weights.W`
    See Also
    --------
    :class:`libpysal.weights.weights.W`
</code></pre>
<p><code>from_xarray</code> method will first check if data can be converted and if the bands is passed or not, if not passed then it&rsquo;ll select first band as default</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Creating weight of object from raster</span>
w_rook <span style="color:#f92672">=</span> Rook<span style="color:#f92672">.</span>from_xarray(da1)
</code></pre></div><pre><code>/data/GSoC/libpysal/libpysal/weights/raster.py:37: UserWarning: Multiple bands detected in the DataArray. Using default band 1 for further computation
  warn('Multiple bands detected in the DataArray. Using default band 1 for further computation')
</code></pre>
<p>This created weight object contains one additional attribute <code>coords</code> which stores the coordinates of non missing values in the form of <code>MultiIndex</code> of <code>pandas.Series</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Quick view at the data stored in coords</span>
w_rook<span style="color:#f92672">.</span>coords[:<span style="color:#ae81ff">5</span>]
</code></pre></div><pre><code>MultiIndex([(1, 4713385.375, 732173.625),
            (1, 4713385.375, 732173.875),
            (1, 4713385.375, 732174.125),
            (1, 4713385.375, 732174.375),
            (1, 4713385.375, 732174.625)],
           names=['band', 'y', 'x'])
</code></pre>
<p>After converting <code>DataArray</code> to <code>pandas,Series</code>, we can access non missing values of raster data (<em>this is still under process of review</em>)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Loading the raster data for further calculation</span>
data1 <span style="color:#f92672">=</span> da1<span style="color:#f92672">.</span>to_series()[w_rook<span style="color:#f92672">.</span>coords]
data1[:<span style="color:#ae81ff">5</span>]
</code></pre></div><pre><code>band  y            x         
1     4713385.375  732173.625    132.0
                   732173.875     94.0
                   732174.125     91.0
                   732174.375    110.0
                   732174.625    106.0
dtype: float64
</code></pre>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Quickly computing and loading a LISA</span>
np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">12345</span>)
lisa <span style="color:#f92672">=</span> Moran_Local(data1,w_rook)
</code></pre></div><p>We&rsquo;ll now try to convert computed data back to <code>xarray.DataArray</code>, we can use <code>to_xarray</code> method belonging to weight method for the transformation.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Let&#39;s check the method first</span>
help(w_rook<span style="color:#f92672">.</span>to_xarray)
</code></pre></div><pre><code>Help on method to_xarray in module libpysal.weights.weights:

to_xarray(data, indices=None, attrs=None) method of libpysal.weights.weights.W instance
    converts the aligned data to a `xarray.DataArray` object
    
    Arguments
    ---------
    data    :   array
                data values stored in 1d array
    indices :   Dictionary/xarray.core.coordinates.DataArrayCoordinates
                coordinates from original DataArray
    attrs   :   Dictionary
                attributes from original DataArray 
    Returns
    -------
    
    da : xarray.DataArray
        instance of xarray.DataArray
</code></pre>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Converting obtained data back to DataArray</span>
moran_da1 <span style="color:#f92672">=</span> w_rook<span style="color:#f92672">.</span>to_xarray(lisa<span style="color:#f92672">.</span>p_sim, da1<span style="color:#f92672">.</span>coords, da1<span style="color:#f92672">.</span>attrs)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Plotting the converted DataArray</span>
moran_da1<span style="color:#f92672">.</span>plot()
</code></pre></div>
    <img src="/images/Untitled_17_1.png"  alt="png"  class="center"  />


<p>We&rsquo;ll now perform same operations on different raster data</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># single band raster data with missing values</span>
da2 <span style="color:#f92672">=</span> xr<span style="color:#f92672">.</span>open_rasterio(<span style="color:#e6db74">&#39;nasadem_sd.tif&#39;</span>)
<span style="color:#75715e"># slicing the dataarray</span>
da2 <span style="color:#f92672">=</span> da2[:, :<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">300</span>:<span style="color:#ae81ff">400</span>]
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># ploting dataarray after removing missing values</span>
da2<span style="color:#f92672">.</span>where(da2<span style="color:#f92672">.</span>data<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>)<span style="color:#f92672">.</span>plot()
</code></pre></div>
    <img src="/images/Untitled_20_1.png"  alt="png"  class="center"  />


<p>This time we will create weights object using <code>Queen</code> class</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Creating weight of object from raster</span>
w_queen <span style="color:#f92672">=</span> Queen<span style="color:#f92672">.</span>from_xarray(da2)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Loading the raster data for further calculation</span>
data2 <span style="color:#f92672">=</span> da2<span style="color:#f92672">.</span>to_series()[w_queen<span style="color:#f92672">.</span>coords]
data2[:<span style="color:#ae81ff">5</span>]
</code></pre></div><pre><code>band  y       x          
1     33.505  -117.509444    256
              -117.509167    261
              -117.508889    263
              -117.508611    263
              -117.508333    264
dtype: int16
</code></pre>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Quickly computing and loading a LISA</span>
np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">12345</span>)
lisa <span style="color:#f92672">=</span> Moran_Local(data2,w_queen)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Let&#39;s check the method first</span>
moran_da2 <span style="color:#f92672">=</span> w_queen<span style="color:#f92672">.</span>to_xarray(lisa<span style="color:#f92672">.</span>p_sim, da2<span style="color:#f92672">.</span>coords, da2<span style="color:#f92672">.</span>attrs)
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Plotting the converted DataArray</span>
moran_da2<span style="color:#f92672">.</span>where(moran_da2<span style="color:#f92672">.</span>data<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>)<span style="color:#f92672">.</span>plot()
</code></pre></div>
    <img src="/images/Untitled_26_1.png"  alt="png"  class="center"  />


<h2 id="experience">Experience</h2>
<p>Without a doubt, this summer has been very interesting and worthwhile with tons of knowledge gained and new things explored related to the project. After every interaction with my mentors, my appreciation for PySAL grow even more, I&rsquo;m able to understand the design decisions went behind the creation of APIs, different methods and overall structure of each module in PySAL library.</p>
<h2 id="whats-next">What’s next?</h2>
<p>There are some API fixes which my mentors suggested I&rsquo;ll work on those side by side I&rsquo;ll also work on the feedback and suggestions which will be given by the community in the upcoming group call and will try to finalize the interface before next week, after that I&rsquo;ll add remaining tests and docstring examples.</p>
<p>Wait for my next blog which will shed some light on the optimization part along with the integration of the interface with other parts of the library&hellip; Till then adios amigos 👋.</p>
]]></content>
        </item>
        
        <item>
            <title>Coding Period: First Phase Part 1</title>
            <link>https://mgeeeek.github.io/posts/2020/06/coding-period-first-phase-part-1/</link>
            <pubDate>Sun, 14 Jun 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/06/coding-period-first-phase-part-1/</guid>
            <description>Community Bonding period ended on 31st May, I covered my experience with PySAL community during the CB period in my last blog. The coding period has started at the beginning of this month and we’ve already reached midway of the first phase. Through this blog, I’ll share what all I’ve been working on during these couple of weeks.
Overview of 2 Spatial Weight Objects During the community bonding period my focus was to grow my understanding of libpysal&#39;s structure, codebase, and API design paradigms.</description>
            <content type="html"><![CDATA[<p><em>Community Bonding period ended on 31st May, I covered my experience with PySAL community during the CB period in my last blog. The coding period has started at the beginning of this month and we’ve already reached midway of the first phase. Through this blog, I’ll share what all I’ve been working on during these couple of weeks.</em></p>
<h2 id="overview-of-2-spatial-weight-objects">Overview of 2 Spatial Weight Objects</h2>
<p>During the community bonding period my focus was to grow my understanding of <code>libpysal</code>'s structure, codebase, and API design paradigms. Along with this, I was looking deeply at the 2 types of spatial class objects used in PySAL namely <code>W</code> &amp; <code>WSP</code> objects which are used to construct spatial weight matrices, specifically I was understanding the logic and structure of each object and ways in which both of them are created. Lemme provides a bit overview of each object (this is a fairly basic explanation, please refer to this <a href="https://youtu.be/fc1f4MNLzdQ?t=5424">video</a> or the main <a href="https://pysal.org/libpysal/">documentation</a> of <code>libpysal</code>).</p>
<p><strong>Spatial Weights Matrix</strong>: In general, it expresses the relationship of a spatial point with its neighboring points. It can be viewed as an adjacency matrix of a weighted graph where each node is connected to other node and these connections follow a specific spatial-contiguity like rook or queen (there are other contiguities as well but these 2 are intuitive to understand).</p>
<p><strong>W object</strong>: It&rsquo;s used to construct spatial weight and represent it in the form of 2 dictionaries-</p>
<ul>
<li><code>neighbors dictionary</code>, where each key specifies a selected point, and the corresponding value is a list containing neighbors of the selected point.</li>
<li><code>weights dictionary</code>, similar to the neighbor dictionary but instead of specifying neighbors, the list contains the weight of each connection of the key to the neighbor listed in the neighbor dictionary.</li>
</ul>
<p><strong>WSP object</strong>: It is also used to construct spatial weight but unlike <code>W</code> object it represents the spatial weights in the form of a sparse matrix where each row shows the relationship of a point with every other point.</p>
<p>Constructing a <code>WSP</code> object requires fewer computation when compared to constructing a <code>W</code> object, but it does not contain the same amount of information as a <code>W</code> object. PySAL&rsquo;s statistical methods operate on these two objects and until now these two objects are mainly derived from vector data (which can be presented in the form of different structures like data frame, shapefiles).</p>
<h2 id="what-did-i-do-this-week">What did I do this week?</h2>
<p>Coming back to the coding period, in my project proposal I listed out the following tasks that I&rsquo;ll work on during first 2 weeks. Slight changes have been made in the timeline after having discussion with my mentors during CBPeriod, it was decided that <code>xarray</code> will be used for the project instead of <code>rasterio</code> because <code>xarray</code> provides a proper structure to the raster&rsquo;s metadata which makes it easy for users to manipulate and access the properties of raster file using <code>xarray.DataArray</code> object.</p>
<blockquote>
<p><em>Week 1 &amp; 2</em> (1st June - 14th June) :</p>
<ul>
<li>List out initial functionalities to be incorporated in the interface.</li>
<li>Implement necessary methods for streamlining the access to raster data using <code>rasterio</code> inside PySAL.</li>
<li>Add methods to extract extract metadata from rasters.</li>
<li>Create an optimized functionality for handling missing values in the raster data used by prototype transformational methods.</li>
<li>Investigate inner working of <code>georasters</code> methods, since some of its functionality can be improved and used for this project.</li>
<li>Discuss the proposed design of the API of interface and this will be worked upon in the next week.</li>
</ul>
</blockquote>
<p>Unfortunately, I had my exams going on during the first week of the coding period, therefore I was a little unproductive and could not completely focus on the project. During this time I set up my development environment, looked at <code>georasters</code> library, and worked on how I can convert <code>xarray.DataArray</code> to weight object.</p>
<p>My exams were over by the first week and I was able to devote more time to the project. My main task for this week was to work on prototype transformational methods that are going to be used in transforming the raster file accessed using <code>xarray</code> to <code>W</code> and <code>SW</code> objects. Along with this I also worked on converting results back to <code>xarray.Dataframe</code> object.</p>
<p>PRs made during this period:</p>
<ul>
<li><a href="https://github.com/MgeeeeK/libpysal/pull/1">Added rast2(W,SW)</a></li>
<li><a href="https://github.com/MgeeeeK/libpysal/pull/2">Added func for creating xr.dataarray</a></li>
</ul>
<p>Since I used the <code>lat2W</code> method, I noticed that the <code>W</code> object stores the neighbors in the list and for large values of rows and columns (2 arguments of the function) the computation runs out of memory, this problem will exist since the methods use eager evaluation. I plan to create an additional method which computes the dictionary values of <code>W</code> object lazily, working with generator objects is tough in this situation since some of the PySAL&rsquo;s methods require all data of <code>W</code> object in memory. This requires more time and I will see if it can be modified in a way so that the PySAL library can work with it.</p>
<h2 id="whats-next">What&rsquo;s next?</h2>
<p>During my recent project call, both mentors reviewed my work and suggested some corrections in the API and the function implementation. In the coming weeks, I have to incorporate the suggested changes and finalize both transformational methods (their APIs and return objects) and also work on the optimization part.</p>
<p>Wait for my next blog which will show the working of my contributed methods&hellip; Till then goodbye 👋.</p>
]]></content>
        </item>
        
        <item>
            <title>Community bonding period wrap-up</title>
            <link>https://mgeeeek.github.io/posts/2020/05/community-bonding-period-wrap-up/</link>
            <pubDate>Sun, 31 May 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/05/community-bonding-period-wrap-up/</guid>
            <description>Today marks the end of the community bonding period and the beginning of the coding period of GSoC. In this blog, I&amp;rsquo;ll share my experience with the PySAL community during the community bonding period. The community bonding period is the starting phase in the GSoC timeline which lasts for almost a month. This period is specially designed for students to get introduced to the community and to understand and learn more about the project before the coding period starts.</description>
            <content type="html"><![CDATA[<h3 id="today-marks-the-end-of-the-community-bonding-period-and-the-beginning-of-the-coding-period-of-gsoc-in-this-blog-ill-share-my-experience-with-the-pysal-community-during-the-community-bonding-period">Today marks the end of the community bonding period and the beginning of the coding period of GSoC. In this blog, I&rsquo;ll share my experience with the PySAL community during the community bonding period.</h3>
<p>The community bonding period is the starting phase in the GSoC timeline which lasts for almost a month. This period is specially designed for students to get introduced to the community and to understand and learn more about the project before the coding period starts. Additionally, students are also expected to become familiar with documentations, open-source practices, and procedures.</p>
<p>Most of my time during the community bonding period was devoted to studying the <code>libpysal</code>'s codebase thoroughly to comprehend its structure, internal functions and testing procedures, I also worked on the examples and read documentation of <code>rasterio</code> and <code>xarray</code> to understand these libraries in depth. Because of my semester getting extended by one month I was not able to dedicate more time to the project as planned earlier in my proposal, I tried to wrap up my coursework, assignments and end-sem exam preparation so that I can completely focus on the project in the coming week.</p>
<h3 id="meetings-and-progress">Meetings and Progress</h3>
<p>In total 3 projects were selected by the PySAL community for this summer. To keep the project-related meetings and interaction more efficient and productive, it was decided by the mentors to coordinate every other week with all gsoc project members and separately in the off-weeks with individual project members. During the community bonding period 3 meetings/calls occurred, one call every Friday.</p>
<ul>
<li>The first call was an introductory meeting involving all students and mentors from each project. This meeting was more about getting to know each other, everyone introduced themselves and also discussed about current state of PySAL and how community use it in their research work. Additionally, we talked about git conventions and setting up the development environment using anaconda. The first meeting was really fruitful and everyone was very friendly and welcoming.</li>
</ul>
<p>Before the next meeting, my project mentors Dani and Stefanie provided me with some additional resources related to the project. Since I&rsquo;m very new in the field of geospatial data science and GIS, I’ve been heavily involved with reading a lot of documentation and learning new things which will help me to get familiar with different statistical methods in PySAL and how they use different data structure as input.</p>
<ul>
<li>The project-specific meeting which happened one week after the first meeting only involved the mentors and student working on that project, mine was related to my project which is Raster awareness in PySAL. I updated the mentors with my proposed approach provided in the proposal, discussed the roadmap for integrating the interface to the library and talked about possible changes in the proposal, it was also cleared by the mentors that the interface with minimal changes in the core computational structure takes priority over making use of Dask since this might require a lot of research and time. The rest of our discussion was related to possible features and functionality to be included after the completion of phase 1. We also discussed about project progress tracking/management and later decided to use issue and PRs with project tag as project tracking diary.</li>
</ul>
<p>Since I&rsquo;d my exams during this week, I was not able to contribute/submit any patch related to the project. Instead, I worked and explored an efficient way to transform <code>xarray.dataArray</code> object to PySAL weight object as discussed during the last meeting. I noticed that while using the <code>Lat2W</code> function I was able to transform correctly, but building a weight object using <code>Lat2W</code> with large values of rows and columns resulted in memory overflow as it uses lists for storing the neighbors, weights, and ids in the dictionary. I&rsquo;m planning to explore this in-depth next week and push a patch related to this.</p>
<ul>
<li>In the last meeting of the community bonding period, mentors cleared some doubts which students had and discussed possible ways of project tracking and management. I also had a call with my project mentors to discuss deliverables I&rsquo;m supposed to work on during the first week of the coding period.</li>
</ul>
<p>With my exams finishing up in the mid of next week, I am looking forward to having a really productive and wonderful summer ahead, learning and contributing exciting stuff to PySAL. Till then, adios !!</p>
]]></content>
        </item>
        
        <item>
            <title>$ sudo make my summer thrilling</title>
            <link>https://mgeeeek.github.io/posts/2020/05/sudo-make-my-summer-thrilling/</link>
            <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/05/sudo-make-my-summer-thrilling/</guid>
            <description>It’s been a while since I posted or blogged about something, and the situation looks still the same&amp;hellip;
Coming to some good news&amp;hellip; My last blog ended with the submission of my GSoC proposal. From the framing of my sentence you would&amp;rsquo;ve guessed already that my GSoC2020 proposal got accepted. I wanted to tell you about this on the day I received my acceptance letter but this semester drained the soul out of me just like what happened to prison mike in prison.</description>
            <content type="html"><![CDATA[<p>It’s been a while since I posted or blogged about something, and the situation looks still the same&hellip;</p>
<p>Coming to some good news&hellip; My last blog ended with the submission of my GSoC proposal. From the framing of my sentence you would&rsquo;ve guessed already that my GSoC2020 proposal got accepted. I wanted to tell you about this on the day I received my acceptance letter but this semester drained the soul out of me just like what happened to prison mike in prison. But on the serious note, I&rsquo;ll work under NumFOCUS which is an umbrella organization supporting relatively small organizations related to scientific computing. The organization I&rsquo;ve chosen under NumFOCUS is PySAL (an abbreviation of Python Spatial Analysis Library) mainly used in geospatial data science. My project <strong><em>Raster awareness in PySAL</em></strong> proposes an interface that will support PySAL’s statistical operations on raster objects (more details can be obtained from the <a href="https://summerofcode.withgoogle.com/projects/5775104799145984">abstract</a>). The project focuses more on the core part of the library and connects with other analytical and statistical components of PySAL, which makes it really interesting and therefore I’m super excited to work on it this summer.</p>
<p>Time for me to take the leave. I hope this situation gets over as soon as possible&hellip; till then goodbye, lock yourself at home and stay safe, more importantly, wait for my next blog which will be related to my initial work on the project.</p>
]]></content>
        </item>
        
        <item>
            <title>$ blog init</title>
            <link>https://mgeeeek.github.io/posts/2020/03/blog-init/</link>
            <pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate>
            
            <guid>https://mgeeeek.github.io/posts/2020/03/blog-init/</guid>
            <description>From now on I&amp;rsquo;ll try to document all the major experiences I&amp;rsquo;ve gained involving opensource development, research work, and exciting stuff like game-theory, python-libraries, Linux-distro-kernel(this is what I come to when I&amp;rsquo;m super bored), philosophy-morality-religion(I&amp;rsquo;m being pretentious now), and most importantly trending topics in the field of AI/ML&amp;hellip; let&amp;rsquo;s leave right here cos I don&amp;rsquo;t have anything in my mind right now except for thinking about the ongoing situation because of the pandemic.</description>
            <content type="html"><![CDATA[<p>From now on I&rsquo;ll <strong>try</strong> to document all the major experiences I&rsquo;ve gained involving opensource development, research work, and exciting stuff like game-theory, python-libraries, Linux-distro-kernel(this is what I come to when I&rsquo;m super bored), philosophy-morality-religion(I&rsquo;m being pretentious now), and most importantly trending topics in the field of AI/ML&hellip; let&rsquo;s leave right here cos I don&rsquo;t have anything in my mind right now except for thinking about the ongoing situation because of the pandemic. I&rsquo;ll also submit my GSoC proposal today (hopefully I&rsquo;ll get selected&hellip; oh boy!! super excited for this summer). Till then goodbye, lock yourself at home&hellip; and stay safe.</p>
]]></content>
        </item>
        
    </channel>
</rss>
